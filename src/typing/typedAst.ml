(**************************************************************************)
(*  This program is free software; you can redistribute it and/or modify  *)
(*  it under the terms of the GNU General Public License as published by  *)
(*  the Free Software Foundation; version 2 of the License.               *)
(*                                                                        *)
(*  This program is distributed in the hope that it will be useful, but   *)
(*  WITHOUT ANY WARRANTY; without even the implied warranty of            *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *)
(*  General Public License for more details.                              *)
(*                                                                        *)
(*  You should have received a copy of the GNU General Public License     *)
(*  along with this program; if not, write to the Free Software           *)
(*  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *)
(*  02110-1301 USA                                                        *)
(*                                                                        *)
(**************************************************************************)

open Parsing

(* Useful type abbreviations *)

(* types generated by type-checking *)
type typ = MultiEquation.crterm

(* source level expressions, patterns, constants, functions, statements *)
type exp = (typ, TypeInfer.varid, Ast.mod_qual) Ast.expr
type pat = (typ, TypeInfer.varid, Ast.mod_qual) Ast.pattern
type const = (typ, TypeInfer.varid, Ast.mod_qual) Ast.const_defn
type func = (typ, TypeInfer.varid, Ast.mod_qual) Ast.fun_defn
type stmt = (typ, TypeInfer.varid, Ast.mod_qual) Ast.stmt

(* source-level regexps, rule-elements, rules and non-terminals *)
type regexp         = (typ, TypeInfer.varid, Ast.mod_qual) Ast.regexp
type rule_elem      = (typ, TypeInfer.varid, Ast.mod_qual) Ast.rule_elem
type rule           = (typ, TypeInfer.varid, Ast.mod_qual) Ast.rule
type non_term_defn  = (typ, TypeInfer.varid, Ast.mod_qual) Ast.non_term_defn
type format_decl    = (typ, TypeInfer.varid, Ast.mod_qual) Ast.format_decl
type ffi_decl       = (typ, TypeInfer.varid, Ast.mod_qual) Ast.ffi_decl

(* source-level spec *)
type format         = (typ, TypeInfer.varid, Ast.mod_qual) Ast.format
type spec_module    = (typ, TypeInfer.varid) Ast.spec_module

(* Useful type utilities *)

(* Extract out the element type of a list type.  This should only be
   called for ground list types. *)
let list_elem (t: typ) : typ =
  let qs, (_tv, lt, ts, _, _, _) = TypeEnvPrinter.term_type_info false t in
  assert (List.length qs = 0);
  assert (List.length ts = 1);
  assert (lt = (Ast.(Modul Mod_stdlib), Ast.TName "[]"));
  let TypeEnvPrinter.(Arg le) = List.hd ts in
  let tv, _le, ts, _, _, _ = le in
  assert (List.length ts = 0);
  CoreAlgebra.TVariable tv
