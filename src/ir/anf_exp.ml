(**************************************************************************)
(*  This program is free software; you can redistribute it and/or modify  *)
(*  it under the terms of the GNU General Public License as published by  *)
(*  the Free Software Foundation; version 2 of the License.               *)
(*                                                                        *)
(*  This program is distributed in the hope that it will be useful, but   *)
(*  WITHOUT ANY WARRANTY; without even the implied warranty of            *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *)
(*  General Public License for more details.                              *)
(*                                                                        *)
(*  You should have received a copy of the GNU General Public License     *)
(*  along with this program; if not, write to the Free Software           *)
(*  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *)
(*  02110-1301 USA                                                        *)
(*                                                                        *)
(**************************************************************************)

open Parsing
open Typing
open Anf
open Anf_pattern

(* expression normalizer *)

type subexp =
  | S_var of av
  | S_let of var * aexp * av

(* Simplify nested lets of the form
     let v = let w = a ... in b in d
   to
     let w = a in ... let v = b in d *)
let rec mk_normalized_let v ae bd typ loc =
  match ae.aexp with
    | AE_let (v', ae', bd') ->
        let bd''  = mk_normalized_let v bd' bd typ loc in
        {aexp     = AE_let (v', ae', bd'');
         aexp_typ = bd''.aexp_typ;
         aexp_loc = bd''.aexp_loc}
    | _ ->
        {aexp     = AE_let (v, ae, bd);
         aexp_typ = typ;
         aexp_loc = loc}

(* When normalizing subexpressions, avoid creating let bindings
   for subexpressions that are already variables, since that will
   result in inefficient redundant renaming. *)
let rec subnorm tenv venv (e: exp) : subexp * VEnv.t =
  match e.expr with
    | E_var v ->
        let v' = VEnv.lookup venv v in
        let v' = make_av (AV_var v') e.expr_aux e.expr_loc in
        S_var v', venv
    | E_mod_member (m, f) ->
        let v = make_av (AV_mod_member (m, f)) e.expr_aux e.expr_loc in
        S_var v, venv
    | _ ->
        let e', venv  = normalize_exp tenv venv e in
        let vid, venv = VEnv.gen venv in
        let v  = make_var vid e.expr_aux e.expr_loc in
        let av = make_av (AV_var vid) e.expr_aux e.expr_loc in
        S_let (v, e', av), venv

(* The main expression normalizer *)
and normalize_exp tenv venv (e: exp) : aexp * VEnv.t =
  let loc = e.expr_loc in
  let wrap e' =
    make_ae e' e.expr_aux loc in
  let make_lets binds ae =
    (* The bindings in [binds] are executed in reverse order,
       relying on the fact that the [binds] are themselves in
       reverse order having been generated by a List.fold_left. *)
    List.fold_left (fun ae' (v, ae) ->
        mk_normalized_let v ae ae' ae'.aexp_typ ae'.aexp_loc
      ) ae binds in
  match e.expr with
    | E_var v ->
        let v' = VEnv.lookup venv v in
        let t  = e.expr_aux in
        let l  = Location.loc v in
        let v' = make_av (AV_var v') t l in
        wrap (AE_val v'), venv
    | E_literal l ->
        let v' = make_av (AV_lit l) e.expr_aux e.expr_loc in
        wrap (AE_val v'), venv
    | E_constr (c, es) ->
        (* Order of evaluation is left-to-right *)
        let (binds, vs), venv =
          List.fold_left (fun ((binds, vs), venv) e ->
              let se, venv = subnorm tenv venv e in
              (match se with
                 | S_var av          -> binds, av :: vs
                 | S_let (v, ae, av) -> (v, ae) :: binds, av :: vs
              ), venv
            ) (([], []), venv) es in
        let v  = AV_constr (convert_con c, List.rev vs) in
        let av = make_av v e.expr_aux e.expr_loc in
        let ae = make_lets binds (wrap (AE_val av)) in
        ae, venv
    | E_record fs ->
        (* Order of evaluation is first to last *)
        let (binds, fvs), venv =
          List.fold_left (fun ((binds, vs), venv) (f, e) ->
              let se, venv = subnorm tenv venv e in
              (match se with
                 | S_var av          -> binds, (f, av) :: vs
                 | S_let (v, ae, av) -> (v, ae) :: binds, (f, av) :: vs
              ), venv
            ) (([], []), venv) fs in
        let v  = AV_record (List.rev fvs) in
        let av = make_av v e.expr_aux e.expr_loc in
        let ae = make_lets binds (wrap (AE_val av)) in
        ae, venv
    | E_apply (f, es) ->
        (* Order of evaluation is function first, and then args
           left-to-right. *)
        let sf, venv  = subnorm tenv venv f in
        let binds, fv = match sf with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let (binds, vs), venv =
          List.fold_left (fun ((binds, vs), venv) e ->
              let se, venv = subnorm tenv venv e in
              (match se with
                 | S_var av          -> binds, av :: vs
                 | S_let (v, ae, av) -> (v, ae) :: binds, av :: vs
              ), venv
            ) ((binds, []), venv) es in
        let fv =
          let wrap f =
            {fv = f; fv_typ = fv.av_typ; fv_loc = fv.av_loc} in
          (* narrow the value to the possible function values *)
          match fv.av with
            | AV_var v -> wrap (FV_var v)
            | AV_mod_member (m, c) -> wrap (FV_mod_member (m, c))
            | _ -> assert false in
        let ae = wrap (AE_apply (fv, List.rev vs)) in
        let ae = make_lets binds ae in
        ae, venv
    | E_unop (op, e) ->
        let se, venv  = subnorm tenv venv e in
        let binds, av = match se with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let ae = wrap (AE_unop (op, av)) in
        let ae = make_lets binds ae in
        ae, venv
    | E_binop (op, l, r) ->
        (* Order of evaluation is left then right *)
        (* TODO: boolean short-circuit *)
        let sl, venv  = subnorm tenv venv l in
        let sr, venv  = subnorm tenv venv r in
        let binds, lv = match sl with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let binds, rv = match sr with
            | S_var av          -> binds, av
            | S_let (v, ae, av) -> (v, ae) :: binds, av in
        let ae = wrap (AE_binop (op, lv, rv)) in
        let ae = make_lets binds ae in
        ae, venv
    | E_recop ((m, r, op), e) ->
        let bfi = TypedAstUtils.lookup_bitfield_info tenv m r in
        let se, venv  = subnorm tenv venv e in
        let binds, av = match se with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let m = modul_of_mname m in
        let ae = match Location.value op with
            | "bits"   -> wrap (AE_bits_of_rec (m, r, av, bfi))
            | "record" -> wrap (AE_rec_of_bits (m, r, av, bfi))
            | _        -> assert false in
        let ae = make_lets binds ae in
        ae, venv
    | E_bitrange (e, f, l) ->
        let se, venv  = subnorm tenv venv e in
        let binds, av = match se with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let ae = wrap (AE_bitrange (av, f, l)) in
        let ae = make_lets binds ae in
        ae, venv
    | E_match (e, c) ->
        let se, venv  = subnorm tenv venv e in
        let binds, av = match se with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let ae = wrap (AE_match (av, convert_con c)) in
        let ae = make_lets binds ae in
        ae, venv
    | E_field (e, f) ->
        let se, venv  = subnorm tenv venv e in
        let binds, av = match se with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let ae = wrap (AE_field (av, f)) in
        let ae = make_lets binds ae in
        ae, venv
    | E_mod_member (m, id) ->
        let mm = make_av (AV_mod_member (m, id)) e.expr_aux e.expr_loc in
        wrap (AE_val mm), venv
    | E_cast (e, t) ->
        let se, venv  = subnorm tenv venv e in
        let binds, av = match se with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let ae = wrap (AE_cast (av, t)) in
        let ae = make_lets binds ae in
        ae, venv
    | E_let (p, pe, e) ->
        let spe, venv = subnorm tenv venv pe in
        let binds, av = match spe with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        (* this is a special case of pattern matching *)
        let cases = [p, e] in
        let ae, venv = normalize_exp_case tenv venv av cases loc in
        let ae = make_lets binds ae in
        ae, venv
    | E_case (e, cases) ->
        let se, venv  = subnorm tenv venv e in
        let binds, av = match se with
            | S_var av          -> [], av
            | S_let (v, ae, av) -> [v, ae], av in
        let ae, venv = normalize_exp_case tenv venv av cases loc in
        let ae = make_lets binds ae in
        ae, venv

and normalize_exp_case (tenv: TypingEnvironment.environment)
      (venv: VEnv.t) (scrutinee: av) (cases: (pat * exp) list) loc
    : aexp * VEnv.t =
  (* Construct the pattern-action matrix, and collect the action-label
     to action map as well as the pattern variables bound in each
     action. *)
  let pmat, act_infos, _ =
    List.fold_left (fun (pmat, act_infos, albl) (p, e) ->
        ([p], albl) :: pmat,
        (albl, (e, pvar_paths p)) :: act_infos,
        albl + 1
      ) ([], [], 0) cases in
  let pmat = List.rev pmat in
  (* construct a decision tree for the pattern-action matrix *)
  let dt = to_decision_tree tenv pmat loc in
  (* convert a decision tree into an ANF expression *)
  let rec unfold venv dt : aexp * VEnv.t =
    match dt with
      | Leaf a ->
          (* TODO: if any action is invoked more than once, create a
             function for the action and call it at the leafs for it.
             Otherwise, the action can be inlined at the single leaf
             resolving to it. *)
          let act, pvs = List.assoc a act_infos in
          (* Bind a new ANF variable in the variable environment for
             each pvar *)
          let letpats, venv =
            List.fold_left (fun (letpats, venv) (v, t, occ) ->
                if   VEnv.is_bound venv v
                then letpats, venv
                else let avar, venv = VEnv.bind venv v in
                     let var = make_var avar t (Location.loc v) in
                     (var, occ) :: letpats, venv

              ) ([], venv) pvs in
          (* Normalize the action expression in this augmented
             variable environment *)
          let ae, venv = normalize_exp tenv venv act in
          (* Wrap the normalized action in the letpat bindings to
             bind the new ANF variables *)
          let ae =
            List.fold_left (fun ae (avar, occ) ->
                make_ae (AE_letpat (avar, (scrutinee, occ), ae))
                  ae.aexp_typ ae.aexp_loc
              ) ae letpats in
          ae, venv
      | Switch (occ, subtree) ->
          (* Convert the subtree into cases for an ANF case.  The type
             of the sub-term being matched at the occurence is that of
             any of the head constructors.  The result type of the ANF
             case will be that of any of the nested case actions. *)
          let cases, venv, opt_typ =
            List.fold_left (fun (cases, venv, _) (con, occ_typ, loc, dt) ->
                let aexp, venv = unfold venv dt in
                let apat =
                  {apat = (match con with
                             | Con (c, _) -> AP_variant c
                             | Lit l      -> AP_literal l
                             | Default    -> AP_wildcard);
                   apat_typ = occ_typ;
                   apat_loc = loc} in
                (apat, aexp) :: cases, venv, Some (occ_typ, aexp.aexp_typ)
              ) ([], venv, None) subtree in
          let cases = List.rev cases in
          (* There should be at least one case (e.g. the default) *)
          let occ_typ, case_typ = match opt_typ with
              | None          -> assert false
              | Some (ot, ct) -> ot, ct in
          (* Bind an ANF variable to the subterm being scrutinized,
             unless it is the root of a variable term *)
          (match scrutinee.av with
             | AV_var v when occ = root_occurrence ->
                 let var =
                   make_var v scrutinee.av_typ scrutinee.av_loc in
                 make_ae (AE_case (var, cases)) case_typ loc,
                 venv
             | _ ->
                 let v, venv = VEnv.gen venv in
                 let var  = make_var v occ_typ Location.ghost_loc in
                 let aexp =
                   make_ae (AE_case (var, cases)) case_typ loc in
                 (* Wrap the case in a letpat for the ANF variable *)
                 make_ae
                   (AE_letpat (var, (scrutinee, occ), aexp))
                   aexp.aexp_typ
                   loc,
                 venv) in
  (* construct the anf *)
  unfold venv dt

let normalize_const tenv venv (c: const) : aconst * VEnv.t =
  let cident, venv = VEnv.bind venv c.const_defn_ident in
  let cval, venv = normalize_exp tenv venv c.const_defn_val in
  {aconst_ident = cident;
   aconst_val   = cval;
   aconst_mod   = c.const_defn_mod;
   aconst_loc   = c.const_defn_loc},
  venv

let normalize_fun tenv venv (f: func) : afun * VEnv.t =
  let fv, venv = VEnv.bind venv f.fun_defn_ident in
  let fv = make_var fv f.fun_defn_aux f.fun_defn_loc in
  let params, entry_venv =
    List.fold_left (fun (ps, venv) (v, te, t) ->
        let p, venv = VEnv.bind venv v in
        let p = make_var p t Ast.(te.type_expr_loc) in
        p :: ps, venv
      ) ([], venv) f.fun_defn_params in
  let body, venv  = normalize_exp tenv entry_venv f.fun_defn_body in
  {afun_ident     = fv;
   afun_params    = List.rev params;
   afun_body      = body;
   afun_vars      = VEnv.new_since venv entry_venv;
   afun_recursive = f.fun_defn_recursive;
   afun_synth     = f.fun_defn_synth;
   afun_mod       = f.fun_defn_mod;
   afun_loc       = f.fun_defn_loc},
  venv

let normalize_recfuns tenv venv (fs: func list)
        : afun list * VEnv.t =
  (* bind all the function names before normalize the first body *)
  let fids, venv =
    List.fold_left (fun (fids, venv) (f: func) ->
        let fid, venv = VEnv.bind venv f.fun_defn_ident in
        let fid = make_var fid f.fun_defn_aux f.fun_defn_loc in
        fid :: fids, venv
      ) ([], venv) (List.rev fs) in
  (* now do the function bodies *)
  let fs, venv =
    List.fold_left (fun (fs, venv) (fid, (f: func)) ->
        let params, entry_venv =
          List.fold_left (fun (ps, venv) (v, te, t) ->
              let p, venv = VEnv.bind venv v in
              let p = make_var p t Ast.(te.type_expr_loc) in
              p :: ps, venv
            ) ([], venv) f.fun_defn_params in
        let body, venv = normalize_exp tenv entry_venv f.fun_defn_body in
        let f' = {afun_ident     = fid;
                  afun_params    = List.rev params;
                  afun_body      = body;
                  afun_vars      = VEnv.new_since venv entry_venv;
                  afun_recursive = f.fun_defn_recursive;
                  afun_synth     = f.fun_defn_synth;
                  afun_mod       = f.fun_defn_mod;
                  afun_loc       = f.fun_defn_loc} in
        f' :: fs, venv
      ) ([], venv) (List.combine fids fs) in
  List.rev fs, venv

let rec normalize_stmt tenv venv (s: stmt) : astmt * VEnv.t =
  let loc = s.stmt_loc in
  let wrap s' =
    {astmt     = s';
     astmt_loc = loc} in
  (* flatten any nested expression-level lets along with any
     statement-level ones *)
  let get_subnorm_binds se =
    let rec get_binds acc ae =
      match ae.aexp with
        | AE_let (v', ae', bd') ->
            get_binds ((v', ae') :: acc) bd'
        | _ ->
            acc, ae in
    match se with
      | S_var av ->
          [], av
      | S_let (v, ae, av) ->
          let binds, ae' = get_binds [] ae in
          (* this S_let will be the inner-most binding *)
          (v, ae') :: binds, av in
  let rec make_lets binds sn =
    (* The bindings in [binds] are executed in reverse order,
       relying on the fact that the [binds] are themselves in
       reverse order having been generated by a List.fold_left. *)
    match binds with
      | [] ->
          sn
      | (v, ae) :: rest ->
          make_lets rest {astmt     = AS_let (v, ae, sn);
                          astmt_loc = s.stmt_loc} in
  match s.stmt with
    | S_assign (l, r) ->
       (* Initialization of deeply nested records can happen
          inside-out; i.e. outer fields of a nested record may not
          exist before their inner fields are initialized.  Extract
          the suffix of fields in `l` to combine their initialization
          and assignment. *)
        let l, fs    = TypedAstUtils.fields_suffix l in
        let ln, venv = normalize_exp tenv venv l in
        let rn, venv = normalize_exp tenv venv r in
        (* The left hand side can be a possibly empty sequence of
           lets terminated by a variable or a record field; hoist the
           lets out of the assignment. *)
        let rec hoist_lets ae =
          match ae.aexp, fs with
            | AE_val {av = AV_var v; _}, [] ->
                let v = make_var v ln.aexp_typ ln.aexp_loc in
                wrap (AS_set_var (v, rn))
            | AE_val {av = AV_var v; _}, _ :: _ ->
                let v = make_var v ln.aexp_typ ln.aexp_loc in
                wrap (AS_set_field (v, fs, rn))
            | AE_field (_, _), _ ->
                (* This should have been part of the fields suffix. *)
                assert false
            | AE_let (v, ae', ae''), _ ->
                wrap (AS_let (v, ae', hoist_lets ae''))
            | _ ->
                raise (Error (ln.aexp_loc, Unassignable_expression)) in
        hoist_lets ln, venv
    | S_let (p, e, ss) ->
        (* handle this similar to E_let *)
        let se, venv  = subnorm tenv venv e in
        let binds, av = get_subnorm_binds se in
        let cases = [p, ss] in
        let sn, venv = normalize_stmt_case tenv venv av cases loc in
        let sn = make_lets binds sn in
        sn, venv
    | S_case (e, cases) ->
        let se, venv = subnorm tenv venv e in
        let binds, av = get_subnorm_binds se in
        let sn, venv = normalize_stmt_case tenv venv av cases loc in
        let sn = make_lets binds sn in
        sn, venv
    | S_print e ->
        let se, venv = subnorm tenv venv e in
        let binds, av = get_subnorm_binds se in
        let sn = make_lets binds (wrap (AS_print av)) in
        sn, venv

and normalize_stmt_case (tenv: TypingEnvironment.environment)
      (venv: VEnv.t) (scrutinee: av) (cases: (pat * stmt list) list) loc
    : astmt * VEnv.t =
  (* The structure of this function essentially follows that of
     normalize_exp_case above. *)
  let pmat, act_infos, _ =
    List.fold_left (fun (pmat, act_infos, albl) (p, e) ->
        ([p], albl) :: pmat,
        (albl, (e, pvar_paths p)) :: act_infos,
        albl + 1
      ) ([], [], 0) cases in
  let dt = to_decision_tree tenv pmat loc in
  let rec unfold venv dt : astmt * VEnv.t =
    match dt with
      | Leaf a ->
          (* TODO: if any action is invoked more than once, create a
             function for the action and call it at the leafs for it.
             Otherwise, the action can be inlined at the single leaf
             resolving to it. *)
          let act, pvs = List.assoc a act_infos in
          (* Bind a new ANF variable in the variable environment for
             each pvar *)
          let letpats, venv =
            List.fold_left (fun (letpats, venv) (v, t, occ) ->
                if   VEnv.is_bound venv v
                then letpats, venv
                else let avar, venv = VEnv.bind venv v in
                     let var = make_var avar t (Location.loc v) in
                     (var, occ) :: letpats, venv
              ) ([], venv) pvs in
          (* Normalize the action block in this augmented
             variable environment (note the order reversal) *)
          let act, venv =
            List.fold_left (fun (astmts, venv) s ->
                let astmt, venv = normalize_stmt tenv venv s in
                astmt :: astmts, venv
              ) ([], venv) act in
          (* Wrap the normalized action in the letpat bindings to
             bind the new ANF variables, and reorder the reversed
             block. *)
          let astmt =
            {astmt     = AS_block (List.rev act);
             astmt_loc = Location.ghost_loc} in
          let astmt =
            List.fold_left (fun astmt (avar, occ) ->
                {astmt     = AS_letpat (avar, (scrutinee, occ), astmt);
                 astmt_loc = Location.ghost_loc}
              ) astmt letpats in
          astmt, venv
      | Switch (occ, subtree) ->
          (* Convert the subtree into cases for an ANF case.  The type
             of the sub-term being matched at the occurence is that of
             any of the head constructors.  The result type of the ANF
             case will be that of any of the nested case actions. *)
          let cases, venv, opt_typ =
            List.fold_left (fun (cases, venv, _) (con, occ_typ, loc, dt) ->
                let astmt, venv = unfold venv dt in
                let apat =
                  {apat = (match con with
                             | Con (c, _) -> AP_variant c
                             | Lit l      -> AP_literal l
                             | Default    -> AP_wildcard);
                   apat_typ = occ_typ;
                   apat_loc = loc} in
                (apat, astmt) :: cases, venv, Some occ_typ
              ) ([], venv, None) subtree in
          (* There should be at least one case (e.g. the default) *)
          let occ_typ = match opt_typ with
              | None    -> assert false
              | Some ot -> ot in
          (* Bind an ANF variable to the subterm being scrutinized,
             unless it is the root of a variable term *)
          (match scrutinee.av with
             | AV_var v when occ = root_occurrence ->
                 let var =
                   make_var v scrutinee.av_typ scrutinee.av_loc in
                 {astmt     = AS_case (var, cases);
                  astmt_loc = loc},
                 venv
             | _ ->
                 let v, venv = VEnv.gen venv in
                 let var  = make_var v occ_typ Location.ghost_loc in
                 let astmt =
                   {astmt     = AS_case (var, cases);
                    astmt_loc = loc} in
                 (* Wrap the case in a letpat for the ANF variable *)
                 {astmt     = AS_letpat (var, (scrutinee, occ), astmt);
                  astmt_loc = loc},
                 venv) in
  unfold venv dt
