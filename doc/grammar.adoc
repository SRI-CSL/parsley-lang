= Grammar sub-language

The contents of a `format` block in a Parsley specification are
written in the Parsley grammar sub-language.  This block contains a
sequence of definitions of the non-terminals in the grammar.

A non-terminal is defined in terms of a sequence of production rules.
The rules in this sequence are separated by a `;`, which acts as a
top-level ordered choice operator.  When trying to match a
non-terminal at a parsing location, each rule is tried in order, and
the first rule that succeeds is used to compute the value of the
non-terminal (i.e. the synthesized attributes for a standard
non-terminal).

== Defining Non-terminals

A standard Parsley non-terminal is given a name beginning with an
uppercase letter and is declared to have a set of synthesized
attributes, each with an explicitly specified type.  A `:` separates
the attribute name from its type, and these name-type pairs are listed
within `{` and `}`, and separated by `,`.  The production rules for
the non-terminal are specified on the right-hand side of a `:=`
separator.
....
 NT {s1: int, s2: bool} := ...
....
A value of such a non-terminal has a record type whose fields
correspond to these synthesized attributes.  In fact, a record type
can be used as an abbreviation for the declaration of the synthesized
attributes.  For example, the declaration of `NT` above is equivalent
to the one below:
....
 type nt = {s1: int, s2: bool}

 format {
   NT {nt} := ...
 }
....
A non-terminal with an empty set of attributes has a unit type.
....
 Unit {} := ...
....
In this case, the `{` and `}` can be omitted.

NOTE: As with user-defined types, attributes cannot contain function
types.

A non-terminal could have inherited attributes.  These are specified
in name-type pairs similar to synthesized attributes, except that they
are enclosed in `(` and `)` (i.e. in parentheses instead of braces).
....
 NT (i1: bool, i2: int) {s1: int, s2: bool} :=
....
Inherited attributes, if present, need to be specified before any
synthesized attributes.  The declaration of inherited attributes
cannot be abbreviated with a record type, unlike synthesized
attributes.

The non-terminal being defined can be given a short name, which can
used in the right-hand side of the definition for the assignment of
the computed values of the synthesized attributes.
....
 NT n {s1: int, s2: bool} := ...  {n.s1 := ...; n.s2 := ...} ...
....
Such a name should start with a lowercase letter, and needs to appear
immediately after the non-terminal name.

Inherited attributes are accessed directly on the right-hand side of
the definition:
....
 NT n (i1: bool, i2: int) {s1: int, s2: bool} := ... {n.s1 := i2; n.s2 := i1} ...
....

==== Rules and Rule elements

We now turn our focus to the right-hand side of the `:=` of a
non-terminal definition, which consists of a sequence of production
rules separated by `;`.

Each production rule is composed of a sequence of rule elements.  A
rule matches successfully if each element of the rule matches the
input in order.  Parsley provides some primitive rule elements, and
combinators to combine them into more complex elements.

The primitive rule elements are: regular expressions, non-terminals,
constraints, and actions.
