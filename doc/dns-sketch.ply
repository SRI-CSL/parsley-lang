format DNSObj()
{

/*

* Header
** Id
** Flags
** Num of questions
** Number of Answer RRs
** Number of Authority RRs
** Number of Additional RRs
* Questions
* Answers
* Authority
* Additional
* Things we need to add --- 
	1. Specific Integer types
	2. BitObj
	3. NibbleObj
	4. PointerObj
*/

domainlabel := [A-Za-z0-9]* ;;
// In my traces, I see the value \xc0\x0c a lot. "11000000 00001100"
// First two bits indicate that its a pointer, the rest, translating to
// Position 12, mean that the actual domain value may be starting in the 12th byte.

subdomain := (domainlabel '.')* domainlabel ;;
domain := subdomain | ' ' | pointer=PointerObj  


flags {qr:int, opcode:int, aa: int, tc: int, ra: int, rd:int} := 
		qr=IntObj1 
		opcode=IntObj4
		aa=IntObj1
       	tc=IntObj1
		rd=IntObj1
		ra=IntObj1
		z=(IntObj1{3})  // Repeats exactly 3 times?
		rcode=IntObj4
		[z.val[0] == 0 && z.val[1] == 0 && z.val[2] == 0]
		{
		qr = qr.val; opcode = opcode.val;
       	aa = aa.val; tc = tc.val; rd = rd.val; ra = ra.val;
		}
		;;

header {id: int, qr:int, opcode:int, aa:int, tc:int,
       rd:int, ra:int, rcode:int,
       question_count: int, answer_count: int,
       authority_count: int, additional_count: int
       }:= 
		id=IntObj16 
       	flags
		qcount=IntObj16
       	ancount=IntObj16 
		nscount=IntObj16
       	arcount=IntObj16
       // Should validate size of the packet using these values
       {id = id.val; qr = flags.qr.val; opcode = flags.opcode.val;
       	aa = flags.aa.val; tc = flags.tc.val; rd = flags.rd.val; ra = flags.ra.val;
       rcode = flags.rcode.val; question_count = qcount.val;
       answer_count = ancount.val; authority_count = nscount.val;
       additional_count = arcount.val}
       ;;
label := len=IntObj8 repeater=(IntObj8{len.val}) // IntObj8 needs to repeat those many times
[len.val >= 1 && len.val <= 255] ;;

type := ty=IntObj16 [ty.val >= 1 && ty.val <= 16] ;; // "A", "NS", "MD", "MF", "CNAME", "SOA", "MB", "MG", "MR", "NULL", "WKS", "PTR", "HINFO", "MINFO", "MX", "TXT"
class := cy=IntObj16 [cy.val >= 1 && cy.val <= 4] ;; // "IN", "CS", "CH", "HS"

// Some additional values are allowed in the question part, but not in the responses.

qname := label+ '\x00' ;; // Query Label needs to end with 00 byte
qtype := type | qi=IntObj16 [qi.val >= 252 && qi.val <= 255] ;;
qclass {class:int}:= class {class.val = class.cy.val} | qci=IntegerObj16 [qci.val == 255] {class.val = qci.val} ;;

ttl := IntObj32 ;;
rdata := len_rdata=IntObj16 objs=(IntObj8{len_rdata.val}) ;;
rr {domain:str, ttl:int,} := 
		domain type class ttl rdata ;;
question := qname qtype qclass ;;

dns := header questions=question* rrs=rr* end 
	// Verify that the number of questions (QDCOUNT) and answers (ACOUNT+NSCOUNT+ARCOUNT) 
	// match the header values
	[header.question_count === questions.len() && 
	header.answer_count+header.authority_count+header.additional_count == rrs.len()]
	;;

}


