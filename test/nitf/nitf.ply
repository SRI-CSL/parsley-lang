// import basic types
include datatypes
include match

// TABLE 1 NITF FILE HEADER. pg. 15 of NITF spec
type image_segment_tuple = {
    lishn: usize,
    lin: usize
}


// NITF packet type
type nitf_packet = {
    // NITF header starts here
    fhdr: [byte],
    fver: [byte],
    clevel: [byte],
    stype: [byte],
    ostaid: [byte],
    fdt: [byte],
    ftitle: [byte],
    fsclas: [byte],
    fsclsy: [byte],
    fscode: [byte],
    fsctlh: [byte],
    fsrel: [byte],
    fsdctp: [byte],
    fsdcdt: [byte],
    fsdcxm: [byte],
    fsdg: [byte],
    fsdgdt: [byte],
    fscltx: [byte],
    fscatp: [byte],
    fscaut: [byte],
    fscrsn: [byte],
    fssrdt: [byte],
    fsctln: [byte],
    fscop: [byte],
    fscpys: [byte],
    encryp: [byte],
    fbkgc: [byte],
    oname: [byte],
    ophone: [byte],
    fl: usize,
    hl: usize,
    numi: usize,

    // image segment subheader + image segment header len start here
    image_segments: [image_segment_tuple]
}


fun sum(acc: (usize, usize), b: byte) -> (usize, usize) = {
    let (x, y) = acc in
        (x +_u (Usize.of_byte(b) *_u 256u), y +_u 1u)
}

fun byte_to_usize(b: [byte]) -> usize = {
   let (acc, count) = List.fold(sum, (0u, 0u), b) in
    acc
}

format {
    // Table 1 of NITF spec.
    FHDR := !"NITF"!;;
    FVER := !"02.00"!;;

    CLEVEL := (# ["0" .. "9"] ^ 2u#);;

    // STYPE := !"BF01"!;;
    // relaxed version:
    STYPE := (# BCS_A ^ 4u #);;

    // This field shall contain the identification code or name of the
    // originating organization, system, station, or product.
    // It shall not be filled with BCS spaces (0x20). size 10.
    OSTAID := (# BCS_A ^ 10u #);;

    FDT := (#["0" .. "9"] ^ 14u #);;

    FSCLAS := (#["T"|"S"|"C"|"R"|"U"]#);;

    // TOOD: if any other populated with a valid code for the security
    // classification system used: FSCODE, FSCTLH, FSREL, FSDCTP,
    FSCLSY := (# ECS_A ^ 2u #);;
    FSCODE := (# ECS_A ^ 11u #);;
    FTITLE := (# ECS_A ^ 80u #);;
    FSCTLH := (# ECS_A ^ 2u #);;
    FSREL := (# ECS_A ^ 20u #);;
    FSDCTP := (# ["DD" | "DE" | "GD" | "GE" | "O" | "X" | "\x20\x20"] #);;
    CC := (#["0".."9"] ^ 2u #);;
    YY := (#["0".."9"] ^ 2u #);;
    MM := (# ["0"] ["1" .. "9"] | ["1"] ["0" .. "2"] #);;
    DD := (# ["0"] ["1" .. "9"] | ["1"|"2"] ["0" .. "9"] | ["3"]["0" .. "1"] #);;

    CCYYMMDD := (#CC YY MM DD#);;
    FSDCDT := (# CCYYMMDD | ["\x20"]* #);;
    FSDCXM := (# (["X"]["1".. "8"] ) |
                 (["25X"]["1" .. "9"]) |
                 ["DINO"]|
                 ["\x20"]*
               #);;
    FSDG := (# ["S" | "C" | "R" | "\x20"] #);;
    FSDGDT := (# CCYYMMDD | ["\x20"]* #);;
    FSCLTX := (# ECS_A ^ 43u #);;
    FSCATP := (# ["O" | "D" | "M" | "\x20"] #);;
    FSCAUT := (# ECS_A ^ 40u #);;
    FSCRSN := (# ["A" .. "H"] | ["\x20"] #);;
    FSSRDT := (# CCYYMMDD | ["\x20"]* #);;
    FSCTLN := (# ECS_A ^ 15u #);;
    FSCOP := (# ["0" .. "9"] #);;
    FSCPYS := (# ["0" .. "9"] #);;
    ENCRYP := !"\x30"!;;
    FBKGC := (# ["\x00" .. "\xFF"] ^ 3u #);;
    ONAME := (# ECS_A ^ 24u #);;
    OPHONE := (# ECS_A ^ 18u #);;

    FL := (# ["0" .. "9"]#);;
    HL := (# ["0" .. "9"]#);;
    NUMI := (# ["0" .. "9"] ^ 3u #);;

    LISHn := (# ["0" .. "9"] ^ 6u #);;
    LIn := (# ["0" .. "9"] ^ 10u #);;

    ImageSegment imgSeg {image_segment_tuple} :=
    lishn = LISHn
    [byte_to_usize(lishn) >=_u 000439u
        && byte_to_usize(lishn) <=_u 999999u]

    lin = LIn
    [byte_to_usize(lin) >=_u 1u && byte_to_usize(lin) <=_u 9999999999u]
    {
        imgSeg.lishn := byte_to_usize(lishn);
        imgSeg.lin := byte_to_usize(lin)
    };;

    NITFpacket npkt {n: nitf_packet} :=
    fhdr = FHDR
    {npkt.n.fhdr   := fhdr}

    fver = FVER
    {npkt.n.fver   := fver}

    clevel = CLEVEL
    {npkt.n.clevel := clevel}

    stype = STYPE
    [List.length(stype) = 4u]
    {npkt.n.stype  := stype}

    ostaid = OSTAID
    [ostaid != "          "]
    {npkt.n.ostaid := ostaid}

    fdt = FDT
    [List.length(stype) = 14u]
    {npkt.n.fdt    := fdt}

    ftitle = FTITLE
    {npkt.n.ftitle := ftitle}
    fsclas = FSCLAS
    {npkt.n.fsclas := fsclas}

    fsclsy = FSCLSY
    // ask implication
    // if fsclas is not U then FSCLSY cannot be spaces
    [(fsclas != "U" && fsclsy != "  ")]
    {npkt.n.fsclsy := fsclsy}

    fscode = FSCODE
    [(fscode != "           " && fsclsy != "  ")]
    {npkt.n.fscode := fscode}

    fsctlh = FSCTLH
    [(fsctlh != "  " && fsclsy != "  ")]
    {npkt.n.fsctlh := fsctlh}

    fsrel = FSREL
    [(fsrel != "                    " && fsclsy != "  ")]
    {npkt.n.fsrel  := fsrel}

    fsdctp = FSDCTP
    [(fsdctp != "  " && fsclsy != "  ")]
    {npkt.n.fsdctp := fsdctp}

    fsdcdt = FSDCDT
    [(fsdcdt != "        " && fsclsy != "  ")]
    {npkt.n.fsdcdt := fsdcdt}

    fsdcxm = FSDCXM
    [(fsdcxm != "    " && fsclsy != "  ")]
    {npkt.n.fsdcxm := fsdcxm}

    fsdg   = FSDG
    [(fsdg != " " && fsclsy != "  ")]
    {npkt.n.fsdg   := fsdg}

    fsdgdt  = FSDGDT
    [(fsdgdt != "        " && fsclsy != "  ")]
    {npkt.n.fsdgdt := fsdgdt}

    fscltx = FSCLTX
    [(fscltx != "                                           " && fsclsy != "  ")]
    {npkt.n.fscltx := fscltx}

    fscatp = FSCATP
    [(fscatp != " " && fsclsy != "  ")]
    {npkt.n.fscatp := fscatp}

    fscaut = FSCAUT
    [(fscaut != "                                        "
        && fsclsy != "  ")]
    {npkt.n.fscaut := fscaut}

    fscrsn = FSCRSN
    [(fscrsn != " " && fsclsy != "  ")]
    {npkt.n.fscrsn := fscrsn}

    fssrdt = FSSRDT
    [(fssrdt != "        " && fsclsy != "  ")]
    {npkt.n.fssrdt := fssrdt}

    fsctln = FSCTLN
    [(fsctln != "               " && fsclsy != "  ")]
    {npkt.n.fsctln := fsctln}

    fscop  = FSCOP
    {npkt.n.fscop  := fscop}

    fscpys = FSCPYS
    {npkt.n.fscpys := fscpys}

    encryp = ENCRYP
    {npkt.n.encryp := encryp}

    fbkgc  = FBKGC
    {npkt.n.fbkgc  := fbkgc}

    oname  = ONAME
    {npkt.n.oname  := oname}

    ophone = OPHONE
    {npkt.n.ophone := ophone}

    fl     = FL
    [List.length(fl) = 12u]

    hl     = HL
    [List.length(hl) = 6u]

    numi   = NUMI
    [List.length(numi) = 3u]

    images_segments = (ImageSegment^byte_to_usize(numi))
    {
        npkt.n.fl     := byte_to_usize(fl);
        npkt.n.hl     := byte_to_usize(hl);
        npkt.n.numi   := byte_to_usize(numi);

        // parse image segments
        npkt.n.image_segments := images_segments
    }
}
