// Parsley: Foundations of Safe Parsing
// 
// NITF: Image Sub-header Parsley Definition
// 
// SRI International, 2022 - 2023

include character_sets
include imgsubheader_functions

type image_comments = {
    comment: [byte]
}

type image_subheader = {
    im: [byte],         // file part type, size: 2, type: R
    iid1: [byte],       // image identifier 1, size: 10, type: R
    idatim: [byte],     // image date and time, size: 14, type: R
    tgtid: [byte],      // target identifier, size: 17, type: R
    iid2: [byte],       // image identifier 2, size: 80, type: <R>
    isclas: [byte],     // image security classification, size: 1, type: R
    isclsy: [byte],     // image security classification system, size: 2, type <R>
    iscode: [byte],     // image codewords, size: 11, type <R>
    isctlh: [byte],     // image control and handling, size: 2, type <R>
    isrel: [byte],      // image releasing instructions, size: 20, type <R>
    isdctp: [byte],     // image declassification type, size: 2, type <R>
    isdcdt: [byte],     // image declassification date, size: 8, type <R>
    isdcxm: [byte],     // image declassification exemption, size: 4, type <R>
    isdg: [byte],       // image downgrade, size: 1, type <R>
    isdgdt: [byte],     // image downgrade date, size: 8, type <R>
    iscltx: [byte],     // image classification text, size: 43, type <R>
    iscatp: [byte],     // image classification authority type, size: 1, type <R>
    iscaut: [byte],     // image classification authority, size: 40, type <R>
    iscrsn: [byte],     // image classification reason, size: 1, type <R>
    issrdt: [byte],     // image security source date, size: 8, type <R>
    isctln: [byte],     // image security control number, size: 15, type <R>
    encrypt: [byte],    // encryption, size: 1, type R
    isorce: [byte],     // image source, size: 42, type <R>
    nrows: [byte],      // number of significant rows in image, size: 8, type R
    ncols: [byte],      // number of significant columns in image, size: 8, type R
    pvtype: [byte],     // pixel value type, size: 3, type R
    irep: [byte],       // image representation, size: 8, type R
    icat: [byte],       // image category, size: 8, type R
    abpp: [byte],       // actual bits-per-pixel per band, size: 2, type R
    pjust: [byte],      // pixel justification, size: 1, type R
    icords: [byte],     // image coordinate representation, size: 1, type <R>
    // igeolo: [byte],     // image geographic location, size: 60, type C -- TODO
    nicom: [byte],      // number of image comments, size: 1, type R
    icomn: [image_comments],       // image comment n, size: 80, type C 
    ic: [byte],         // image compression, size: 2, type R
    comrat: [byte],     // compression rate code, size: 4, type C -- TODO: Add condition function
    nbands: [byte],     // number of bands, size: 1, type R
    xbands: [byte],     // number of multispectral bands, size: 5, type C
    isync: [byte],      // image sync code, size: 1, type R
    imode: [byte],      // image mode, size: 1, type R
    nbpr: [byte],       // number of blocks per row, size: 4, type R
    nbpc: [byte],       // number of blocks per column, size: 4, type R
    nppbh: [byte],      // number of pixels per block horizontal, size: 4, type R
    nppbv: [byte],      // number of pixels per block vertical, size: 4, type R
    nbpp: [byte],       // number of bits per pixel per band, size: 2, type R
    idlvl: [byte],      // image display level, size: 3, type R
    ialvl: [byte],      // attachment level, size: 3, type R
    iloc: [byte],       // image location, size: 10, type R
    imag: [byte],       // image magnification, size: 4, type R
    udidl: [byte],      // use defined image data length, size: 5, type R
    udofl: [byte],      // user defined overflow, size: 3, type C
    // udid: [byte],       // user defined image data, size: TRE, type C -- TODO
    ixshdl: [byte],     // image extended subheader data length, size: 5, type R
    ixsofl: [byte]      // image extended subheader overflow, size: 3, type C
    // ixshd: [byte]       // image extended subheader data, size TRE, type C -- TODO
}


format {
    IM := !"IM"!;;
    IID1 := (# BCS_A ^ 10u #);;
    IDATIM := (# CCYYMMDDhhmmss #);;

    BE := (# BCS_A ^ 10u #);;
    OSUFFIX := (# BCS_A ^ 5u #);;
    CountryCode := (# BCS_A ^ 2u #);;
    BOC := (# BE OSUFFIX CountryCode #);;
    TGTID := (# BOC | ["\x20"] ^ 17u #);;

    IID2 := (# ECS_A ^ 80u | ["\x20"] ^ 80u #);;
    ISCLAS := (# ["T" | "S" | "C" | "R" | "U" ] #);;
    ISCLSY := (# ECS_A ^ 2u #);;
    ISCODE := (# ECS_A ^ 11u #);;
    ISCTLH := (# ECS_A ^ 2u #);;
    ISREL := (# ECS_A ^ 20u #);;
    ISDCTP := (# ["DD" | "DE" | "GD" | "GE" | "O" | "X" | "\x20\x20"] #);;
    ISDCDT := (# CCYYMMDD | ["\x20"] ^ 8u #);;
    ISDCXM := (# ["X1" .. "X8"] | ["25X1" .. "25X9"] | ["DNIO"] | ["\x20"] ^ 4u #);;
    ISDG := (# ["S" | "C" | "R" | "\x20"] #);;
    ISDGDT := (# CCYYMMDD | ["\x20"] ^ 8u #);;
    ISCLTX := (# ECS_A ^ 43u #);;
    ISCATP := (# ["O" | "D" | "M" | "\x20"] #);;
    ISCAUT := (# ECS_A ^ 40u #);;
    ISCRSN := (# ["A" .. "H"] | ["\x20"] #);;
    ISSRDT := (# CCYYMMDD | ["\x20"] ^ 8u #);;
    ISCTLN := (# ECS_A ^ 20u #);;
    //ENCRYPT := (# BCS_N_INT_POS ^ 1u #);; // FIXME?
    ENCRYPT := (# AsciiCharS ^ 1u #);;
    ISORCE := (# ECS_A ^ 42u #);;
    //NROWS := (# ["00000001" .. "99999999"] #);; // FIXME?
    NROWS := (# AsciiCharS ^ 8u #);;
    //NCOLS := (# ["00000001" .. "99999999"] #);; // FIXME?
    NCOLS := (# AsciiCharS ^ 8u #);;
    //PVTYPE := (# ["INT" | "B" | "SI" | "R" | "C"] ^ 3u #);; // FIXME?
    PVTYPE := (# AsciiCharS ^ 3u #);;
    //IREP := (# ["MONO" | "RGB" | "RGB/LUT" | "MULTI" | "NODISPLY" | "NVECTOR" | "POLAR" | "VPH" | "YCbCr601"] ^ 8u #);; // FIXME?
    IREP := (# AsciiCharS ^ 8u #);;
    ICAT := (# BCS_A ^ 8u #);;
    ABPP := (# ["01" .. "96"] #);;
    // PJUST := (# ["R" | "L"] #);; FIXME?
    PJUST := AsciiCharS;;
    // ICORDS := (#["U" | "G" | "N" | "S" | "P" | "D" | "\x20"] #);; // FIXME?
    ICORDS := AsciiCharS;;
    IGEOLO := (# BCS_A ^ 60u #);;
    // NICOM := (# BCS_N_INT_POS ^ 1u #);;
    NICOM := AsciiCharS;;
    ICOMN := (# ECS_A ^ 80u #);;
    //IC := (# ["NC" | "NM" | "I1"] | ["C1" .. "C8"] | ["M1" .. "M8"] | ["CB" | "MB" | "C9" | "M9" | "CA" | "MA"] #);; // FIXME?
    IC := (# AsciiCharS ^ 2u #);;
    COMRAT := (# BCS_A ^ 4u #);;
    NBANDS := (# BCS_N_INT_POS ^ 1u #);;
    // XBANDS := (# ["00010" .. "99999"] #);;
    XBANDS := (# AsciiCharS ^ 5u #);;
    // ISYNC := (# ["\x30"] ^ 1u #);; // FIXME
    ISYNC := AsciiCharS;;
    // IMODE := (# ["B" | "P" | "R" | "S"] | ["T" | "D" | "E" | "F" | "X" | "Z"] #);; // FIXME?
    IMODE := AsciiCharS;;
    // NBPR := (# ["0001" .. "9999"] #);; // FIXME?
    NBPR := (# AsciiCharS ^ 4u #);;
    NBPC := (# ["0001" .. "9999"] #);;
    // NPP := (# ["0000"] | (["0001" .. "8192"]) #);; // FIXME?
    NPP := (# AsciiCharS ^ 4u #);;
    // NBPP := (# ["01" .. "96"] #);; // FIXME?
    NBPP := (# AsciiCharS ^ 2u #);;
    IDLVL := (# ["001" .. "999"] #);;
    IALVL := (# ["000" .. "998"] | ["\x30"] ^ 3u #);;
    // ILOC := (# BCS_N ^ 10u #);; // FIXME?
    ILOC := (# AsciiCharS ^ 10u #);;
    IMAG := (# BCS_A ^ 4u | ["1.0\x20"] #);;
    // UDIDL := (# ["00000"] | ["00003" .. "99999"] #);; // FIXME?
    UDIDL := (# AsciiCharS ^ 5u #);;
    // IXSHDL := (# ["00000"] | ["00003" .. "99999"] #);; // FIXME?
    IXSHDL := (# AsciiCharS ^ 5u #);;
    // IXSHDL := (# BCS ^ 5u #);;


    ImageComments img_comm {image_comments} :=
        img_comment = ICOMN
        { img_comm.comment := img_comment };;


    ImageSubheader img_subh {image_subheader} := 
        file_part_type = IM
        { 
            img_subh.im := file_part_type;
            $print_t(img_subh.im)
        }

        { $print_t("trying IID1") }
        image_identifier_1 = IID1
        { 
            img_subh.iid1 := image_identifier_1;
            $print_t(img_subh.iid1)
        }

        { $print_t("trying IDATIM") }
        image_date_and_time = IDATIM
        { 
            img_subh.idatim := image_date_and_time;
            $print_t(img_subh.idatim)
        }
        { $print_t("trying TGTID") }
        target_identifier = TGTID
        { 
            img_subh.tgtid := target_identifier
            //$print_t(img_subh.tgtid)
        }
        { $print_t("trying IID2") }
        image_identifier_2 = IID2
        { img_subh.iid2 := image_identifier_2 }

        { $print_t("trying ISCLAS") }
        image_security_classification = ISCLAS
        { img_subh.isclas := image_security_classification;
	  $print_t(img_subh.isclas)
	}

        // Fields from ISCODE until ISCTLN are placed before ISCLSY
        // per interpretation of NOTE at the top of Table 3, pg. 30
        { $print_t("trying ISCODE") }
        image_codewords = ISCODE
        { img_subh.iscode := image_codewords }

        { $print_t("trying ISCTLH") }
        image_control_and_handling = ISCTLH
        { img_subh.isctlh := image_control_and_handling }

        { $print_t("trying ISREL") }
        image_releasing_instructions = ISREL
        { img_subh.isrel := image_releasing_instructions }

        { $print_t("trying ISDCTP") }
        image_declassification_type = ISDCTP
        { img_subh.isdctp := image_declassification_type }

        { $print_t("trying ISDCDT") }
        image_declassification_date = ISDCDT
        // [image_declassification_type = "DD"] todo: revisit this field
        { img_subh.isdcdt := image_declassification_date }

        { $print_t("trying ISDCXM") }
        image_declassification_exemption = ISDCXM
        { img_subh.isdcxm := image_declassification_exemption }

        { $print_t("trying ISDG") }
        image_downgrade = ISDG
        { img_subh.isdg := image_downgrade }

        { $print_t("trying ISDGDT") }
        image_downgrade_date = ISDGDT
        { img_subh.isdgdt := image_downgrade_date }

        { $print_t("trying ISCLTX") }
        image_classification_text = ISCLTX
        { img_subh.iscltx := image_classification_text }

        { $print_t("trying ISCATP") }
        image_classification_authority_type = ISCATP
        { img_subh.iscatp := image_classification_authority_type }

        { $print_t("trying ISCAUT") }
        image_classification_authority = ISCAUT
        { img_subh.iscaut := image_classification_authority }

        { $print_t("trying ISCRSN") }
        image_classification_reason = ISCRSN
        { img_subh.iscrsn := image_classification_reason }

        { $print_t("trying ISSRDT") }
        image_security_source_date = ISSRDT
        { img_subh.issrdt := image_security_source_date }

        { $print_t("trying ISCTLN") }
        image_security_control_number = ISCTLN
        { img_subh.isctln := image_security_control_number }

        { $print_t("trying ISCLSY") }
        image_security_classification_system = ISCLSY
        // [is_valid_isclsy_1(image_security_classification_system, image_security_classification)]
        { img_subh.isclsy := image_security_classification_system }

        { $print_t("trying ENCRYPT") }
        encryption = ENCRYPT
        { img_subh.encrypt := encryption;
	  $print_t(img_subh.encrypt) }

        { $print_t("trying ISORCE") }
        image_source = ISORCE
        { img_subh.isorce := image_source }

        { $print_t("trying NROWS") }
        number_of_significant_rows_in_image = NROWS
        { img_subh.nrows := number_of_significant_rows_in_image;
	  $print_t(img_subh.nrows) }

        { $print_t("trying NCOLS") }
        number_of_significant_cols_in_image = NCOLS
        { img_subh.ncols := number_of_significant_cols_in_image;
	  $print_t(img_subh.ncols) }

        { $print_t("trying PVTYPE") }
        pixel_value_type = PVTYPE
        { img_subh.pvtype := pixel_value_type;
	  $print_t(img_subh.pvtype) }

        { $print_t("trying IREP") }
        image_representation = IREP
        { img_subh.irep := image_representation;
	  $print_t(img_subh.irep) }

        { $print_t("trying ICAT") }
        image_category = ICAT
        { img_subh.icat := image_category }

        { $print_t("trying ABPP") }
        actual_bits_per_pixel_per_band = ABPP
        { img_subh.abpp := actual_bits_per_pixel_per_band }

        { $print_t("trying PJUST") }
        pixel_justification = PJUST
        { img_subh.pjust := pixel_justification;
	  $print_t(img_subh.pjust) }

        { $print_t("trying ICORDS") }
        image_coordinate_representation = ICORDS
        { img_subh.icords := image_coordinate_representation;
	  $print_t(img_subh.icords) }

        // image_geographic_location = IGEOLO
        // { img_subh.igeolo := image_geographic_location }

        { $print_t("trying NICOM") }
        number_of_image_comments = NICOM
        { img_subh.nicom := number_of_image_comments;
	  $print_t(img_subh.nicom) }

        { $print_t(Usize.of_bytes_unsafe(number_of_image_comments) -_u 48u);
	  $print_t("NICOM conversion succeeded") }

        // FIXME: NICOM is decimal text, not binary.  of_bytes takes
        // binary inputs, so you need a helper to convert the ascii
        // decimals (i.e. subtract the ascii '0' (48u) from the byte.
        image_comment_n = (ImageComments^(Usize.of_bytes_unsafe(number_of_image_comments) -_u 48u))
        { img_subh.icomn := image_comment_n }

        { $print_t("trying IC") }
        image_compression = IC
        { 
            img_subh.ic := image_compression;
	        $print_t(img_subh.ic) 
        }

        // BH: PREVIOUS COMRAT VERSION
        // { $print_t("trying COMRAT") }
        // compression_rate_code = COMRAT
        // { img_subh.comrat := compression_rate_code }

        { $print_t("trying COMRAT") }
        compression_rate_code = (AsciiCharS ^ comrat_setup(image_compression))
        { 
            img_subh.comrat := compression_rate_code;
            $print_t(img_subh.comrat)
        }

        { $print_t("trying NBANDS") }
        number_of_bands = NBANDS
        { img_subh.nbands := number_of_bands }
    
    // BH: PREVIOUS XBANDS VERSION
    //     { $print_t("trying XBANDS") }
    //     number_of_multispectral_bands = XBANDS
    //     { img_subh.xbands := number_of_multispectral_bands;
	//   $print_t(img_subh.xbands) }

        { $print_t("trying XBANDS") }
        number_of_multispectral_bands = (AsciiCharS ^ xbands_setup(number_of_bands))
        { 
            img_subh.xbands := number_of_multispectral_bands;
            $print_t(img_subh.xbands) 
        }

        // Fields IREPBANDn to LUTDnm repeat the number of times indicated
        // in the NBANDS field or the XBANDS field

        { $print_t("trying ISYNC") }
        image_sync_code = ISYNC
        { 
            img_subh.isync := image_sync_code;
	        $print_t(img_subh.isync) 
        }

        { $print_t("trying IMODE") }
        image_mode = IMODE
        { 
            img_subh.imode := image_mode;
	        $print_t(img_subh.imode) 
        }

        { $print_t("trying NBPR") }
        number_of_blocks_per_row = NBPR
        { 
            img_subh.nbpr := number_of_blocks_per_row;
	        $print_t(img_subh.nbpr) 
        }

        { $print_t("trying NBPC") }
        number_of_blocks_per_column = NBPC
        { 
            img_subh.nbpc := number_of_blocks_per_column;
	        $print_t(img_subh.nbpc) 
        }

        { $print_t("trying NPPh") }
        number_of_pixels_per_block_horizontal = NPP
        { 
            img_subh.nppbh := number_of_pixels_per_block_horizontal;
	        $print_t(img_subh.nppbh) 
        }

        { $print_t("trying NPPv") }
        number_of_pixels_per_block_vertical = NPP
        { 
            img_subh.nppbv := number_of_pixels_per_block_vertical;
	        $print_t(img_subh.nppbv) 
        }

        { $print_t("trying NBPP") }
        number_of_bits_per_pixel_per_band = NBPP
        { 
            img_subh.nbpp := number_of_bits_per_pixel_per_band;
	        $print_t(img_subh.nbpp) 
        }

        { $print_t("trying IDLVL") }
        image_display_level = IDLVL
        { 
            img_subh.idlvl := image_display_level;
            $print_t(img_subh.idlvl)    
        }

        { $print_t("trying IALVL") }
        attachment_level = IALVL
        { 
            img_subh.ialvl := attachment_level; 
            $print_t(img_subh.ialvl)    
        }

        { $print_t("trying ILOC") }
        image_location = ILOC
        { 
            img_subh.iloc := image_location;
	        $print_t(img_subh.iloc) 
        }

        { $print_t("trying IMAG") }
        image_magnification = IMAG
        { 
            img_subh.imag := image_magnification;
            $print_t(img_subh.imag) 
        }

        { $print_t("trying UDIDL") }
        user_defined_image_data_length = UDIDL
        { 
            img_subh.udidl := user_defined_image_data_length;
	        $print_t(img_subh.udidl) 
        }

        { $print_t("trying UDOFL") }
        user_defined_overflow = (AsciiCharS ^ udofl_setup(user_defined_image_data_length))
        {
            img_subh.udofl := user_defined_overflow;
            $print_t(img_subh.udofl)
        }
        
        // TODO: UDID

        { $print_t("trying IXSHDL") }
        image_extended_subheader_data_length = IXSHDL
        { 
            img_subh.ixshdl := image_extended_subheader_data_length;
            $print_t(img_subh.ixshdl)
        }

        { $print_t("trying IXSOFL") }
        image_extended_subheader_overflow = (AsciiCharS ^ ixsofl_setup(image_extended_subheader_data_length))
        {
            img_subh.ixsofl := image_extended_subheader_overflow;
            $print_t(img_subh.ixsofl)
        }

        // TODO: IXSHD

        // OBSERVATION: Fields like IXSHD (Image Extended Subheader Data) are to be omitted
        // if the field they are conditioned upon, in this case IXHDL (Image Extended Subheader Data Length)
        // contains BCS zeros (0x30).
        // Per the above statement it is NOT clear whether the field should contain ALL zeroes
        // or if the presence of even one zero is sufficient to omit the field in question, in this case IXSHD.
        

}
