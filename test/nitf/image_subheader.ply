// Parsley: Foundations of Safe Parsing
// 
// NITF: Image Sub-header Parsley Definition
// 
// SRI International, 2022

include character_sets

fun is_valid_isclsy_1(isclas: [byte], isclsy: [byte]) -> bool = {
    (case isclas of
        | "U" -> bool::True()
        | _ -> (case isclsy of
                    | "  " -> bool::False()
                    | _ -> bool::True()
                )
    )
}

type image_comments = {
    comment: [byte]
}

type image_subheader = {
    im: [byte],         // file part type, size: 2, type: R
    iid1: [byte],       // image identifier 1, size: 10, type: R
    idatim: [byte],     // image date and time, size: 14, type: R
    tgtid: [byte],      // target identifier, size: 17, type: R
    iid2: [byte],       // image identifier 2, size: 80, type: <R>
    isclas: [byte],     // image security classification, size: 1, type: R
    isclsy: [byte],     // image security classification system, size: 2, type <R>
    iscode: [byte],     // image codewords, size: 11, type <R>
    isctlh: [byte],     // image control and handling, size: 2, type <R>
    isrel: [byte],      // image releasing instructions, size: 20, type <R>
    isdctp: [byte],     // image declassification type, size: 2, type <R>
    isdcdt: [byte],     // image declassification date, size: 8, type <R>
    isdcxm: [byte],     // image declassification exemption, size: 4, type <R>
    isdg: [byte],       // image downgrade, size: 1, type <R>
    isdgdt: [byte],     // image downgrade date, size: 8, type <R>
    iscltx: [byte],     // image classification text, size: 43, type <R>
    iscatp: [byte],     // image classification authority type, size: 1, type <R>
    iscaut: [byte],     // image classification authority, size: 40, type <R>
    iscrsn: [byte],     // image classification reason, size: 1, type <R>
    issrdt: [byte],     // image security source date, size: 8, type <R>
    isctln: [byte],     // image security control number, size: 15, type <R>
    encryp: [byte],     // encryption, size: 1, type R
    isorce: [byte],     // image source, size: 42, type <R>
    nrows: [byte],      // number of significant rows in image, size: 8, type R
    ncols: [byte],      // number of significant columns in image, size: 8, type R
    pvtype: [byte],     // pixel value type, size: 3, type R
    irep: [byte],       // image representation, size: 8, type R
    icat: [byte],       // image category, size: 8, type R
    abpp: [byte],       // actual bits-per-pixel per band, size: 2, type R
    pjust: [byte],      // pixel justification, size: 1, type R
    icords: [byte],     // image coordinate representation, size: 1, type <R>
    // igeolo: [byte],     // image geographic location, size: 60, type C -- TODO
    nicom: [byte],      // number of image comments, size: 1, type R
    // icomn: [image_comments]       // image comment n, size: 80, type C -- TODO
    ic: [byte],         // image compression, size: 2, type R
    comrat: [byte],     // compression rate code, size: 4, type C -- TODO: Add condition function
    nbands: [byte],     // number of bands, size: 1, type R
    xbands: [byte],     // number of multispectral bands, size: 5, type C -- TODO: Add condition function
    isync: [byte],      // image sync code, size: 1, type R
    imode: [byte],      // image mode, size: 1, type R
    nbpr: [byte],       // number of blocks per row, size: 4, type R
    nbpc: [byte],       // number of blocks per column, size: 4, type R
    nppbh: [byte],      // number of pixels per block horizontal, size: 4, type R
    nppbv: [byte]       // number of pixels per block vertical, size: 4, type R
}


format {
    IM := !"IM"!;;
    IID1 := (# BCS_A ^ 10u #);;
    IDATIM := (# CCYYMMDDhhmmss #);;

    BE := (# BCS_A ^ 10u #);;
    OSUFFIX := (# BCS_A ^ 5u #);;
    CountryCode := (# BCS_A ^ 2u #);;
    BOC := (# BE OSUFFIX CountryCode #);;
    TGTID := (# BOC | ["\x20"] ^ 17u #);;

    IID2 := (# ECS_A ^ 80u | ["\x20"] ^ 80u #);;
    ISCLAS := (# ["T" | "S" | "C" | "R" | "U" ] #);;
    ISCLSY := (# ECS_A ^ 2u #);;
    ISCODE := (# ECS_A ^ 11u #);;
    ISCTLH := (# ECS_A ^ 2u #);;
    ISREL := (# ECS_A ^ 20u #);;
    ISDCTP := (# ["DD" | "DE" | "GD" | "GE" | "O" | "X" | "\x20\x20"] #);;
    ISDCDT := (# CCYYMMDD | ["\x20"] ^ 8u #);;
    ISDCXM := (# ["X1" .. "X8"] | ["25X1" .. "25X9"] | ["DNIO"] | ["\x20"] ^ 4u #);;
    ISDG := (# ["S" | "C" | "R" | "\x20"] #);;
    ISDGDT := (# CCYYMMDD | ["\x20"] ^ 8u #);;
    ISCLTX := (# ECS_A ^ 43u #);;
    ISCATP := (# ["O" | "D" | "M" | "\x20"] #);;
    ISCAUT := (# ECS_A ^ 40u #);;
    ISCRSN := (# ["A" .. "H"] | ["\x20"] #);;
    ISSRDT := (# CCYYMMDD | ["\x20"] ^ 8u #);;
    ISCTLN := (# ECS_A ^ 20u #);;
    ENCRYP := (# BCS_N_INT_POS ^ 1u #);;
    ISORCE := (# ECS_A ^ 42u #);;
    NROWS := (# ["00000001" .. "99999999"] #);;
    NCOLS := (# ["00000001" .. "99999999"] #);;
    PVTYPE := (# ["INT" | "B" | "SI" | "R" | "C"] ^ 3u #);;
    IREP := (# ["MONO" | "RGB" | "RGB/LUT" | "MULTI" | "NODISPLY" | "NVECTOR" | "POLAR" | "VPH" | "YCbCr601"] ^ 8u #);;
    ICAT := (# BCS_A ^ 8u #);;
    ABPP := (# ["01" .. "96"] #);;
    PJUST := (# ["R" | "L"] #);;
    ICORDS := (#["U" | "G" | "N" | "S" | "P" | "D" | "\x20"] #);;
    IGEOLO := (# BCS_A ^ 60u #);;
    NICOM := (# BCS_N_INT_POS ^ 1u #);;
    ICOMN := (# ECS_A ^ 80u #);;
    IC := (# ["NC" | "NM" | "I1"] | ["C1" .. "C8"] | ["M1" .. "M8"] | ["CB" | "MB" | "C9" | "M9" | "CA" | "MA"] #);;
    COMRAT := (# BCS_A ^ 4u #);;
    NBANDS := (# BCS_N_INT_POS ^ 1u #);;
    XBANDS := (# ["00010" .. "99999"] #);;
    ISYNC := (# ["\x30"] ^ 1u #);;
    IMODE := (# ["B" | "P" | "R" | "S"] | ["T" | "D" | "E" | "F" | "X" | "Z"] #);;
    NBPR := (# ["0001" .. "9999"] #);;
    NBPC := (# ["0001" .. "9999"] #);;
    NPP := (# ["0000"] | ["0001" .. "8192"] #);;

    ImageComments img_comm {image_comments} :=
        img_comment = ICOMN
        { img_comm.comment := img_comment };;

    ImageSubheader img_subh {image_subheader} := 
        file_part_type = IM
        { img_subh.im := file_part_type }

        image_identifier_1 = IID1
        { img_subh.iid1 := image_identifier_1 }

        image_date_and_time = IDATIM
        { img_subh.idatim := image_date_and_time }

        target_identifier = TGTID
        { img_subh.tgtid := target_identifier }

        image_identifier_2 = IID2
        { img_subh.iid2 := image_identifier_2 }

        image_security_classification = ISCLAS
        { img_subh.isclas := image_security_classification }

        // Fields from ISCODE until ISCTLN are placed before ISCLSY
        // per interpretation of NOTE at the top of Table 3, pg. 30
        image_codewords = ISCODE
        { img_subh.iscode := image_codewords }

        image_control_and_handling = ISCTLH
        { img_subh.isctlh := image_control_and_handling }

        image_releasing_instructions = ISREL
        { img_subh.isrel := image_releasing_instructions }

        image_declassification_type = ISDCTP
        { img_subh.isdctp := image_declassification_type }

        image_declassification_date = ISDCDT
        // [image_declassification_type = "DD"] todo: revisit this field
        { img_subh.isdcdt := image_declassification_date }

        image_declassification_exemption = ISDCXM
        { img_subh.isdcxm := image_declassification_exemption }

        image_downgrade = ISDG
        { img_subh.isdg := image_downgrade }

        image_downgrade_date = ISDGDT
        { img_subh.isdgdt := image_downgrade_date }

        image_classification_text = ISCLTX
        { img_subh.iscltx := image_classification_text }

        image_classification_authority_type = ISCATP
        { img_subh.iscatp := image_classification_authority_type }

        image_classification_authority = ISCAUT
        { img_subh.iscaut := image_classification_authority }

        image_classification_reason = ISCRSN
        { img_subh.iscrsn := image_classification_reason }

        image_security_source_date = ISSRDT
        { img_subh.issrdt := image_security_source_date }

        image_security_control_number = ISCTLN
        { img_subh.isctln := image_security_control_number }

        image_security_classification_system = ISCLSY
        [is_valid_isclsy_1(image_security_classification_system, image_security_classification)]
        { img_subh.isclsy := image_security_classification_system }

        encryption = ENCRYP
        { img_subh.encryp := encryption }

        image_source = ISORCE
        { img_subh.isorce := image_source }

        number_of_significant_rows_in_image = NROWS
        { img_subh.nrows := number_of_significant_rows_in_image }

        number_of_significant_cols_in_image = NCOLS
        { img_subh.ncols := number_of_significant_cols_in_image }

        pixel_value_type = PVTYPE
        { img_subh.pvtype := pixel_value_type }

        image_representation = IREP
        { img_subh.irep := image_representation }

        image_category = ICAT
        { img_subh.icat := image_category }

        actual_bits_per_pixel_per_band = ABPP
        { img_subh.abpp := actual_bits_per_pixel_per_band }

        pixel_justification = PJUST
        { img_subh.pjust := pixel_justification }

        image_coordinate_representation = ICORDS
        { img_subh.icords := image_coordinate_representation }

        // image_geographic_location = IGEOLO
        // { img_subh.igeolo := image_geographic_location }

        number_of_image_comments = NICOM
        { img_subh.nicom := number_of_image_comments }

        // image_comment_n = (ImageComments^Usize.of_byte(number_of_image_comments))
        // { img_subh.icomn := image_comment_n }
        
        image_compression = IC
        { img_subh.ic := image_compression }

        compression_rate_code = COMRAT
        { img_subh.comrat := compression_rate_code }

        number_of_bands = NBANDS
        { img_subh.nbands := number_of_bands }

        number_of_multispectral_bands = XBANDS
        { img_subh.xbands := number_of_multispectral_bands }

        // Fields IREPBANDn to LUTDnm repeat the number of times indicated
        // in the NBANDS field or the XBANDS field

        image_sync_code = ISYNC
        { img_subh.isync := image_sync_code }

        image_mode = IMODE
        { img_subh.imode := image_mode }

        number_of_blocks_per_row = NBPR
        { img_subh.nbpr := number_of_blocks_per_row }

        number_of_blocks_per_column = NBPC
        { img_subh.nbpc := number_of_blocks_per_column }

        number_of_pixels_per_block_horizontal = NPP
        { img_subh.nppbh := number_of_pixels_per_block_horizontal }

        number_of_pixels_per_block_vertical = NPP
        { img_subh.nppbv := number_of_pixels_per_block_vertical }

}