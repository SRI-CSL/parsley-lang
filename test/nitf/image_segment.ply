// NITF Image Segment Parsley Definition
// 
// SRI International, 2022

// Briland Notes
// -------------
// - An Image Segment (IS) supports the standard image type of data, see pg. 5 of NITF spec.
// - There can be n-Image Data Segments organized as: 
//   (image_subheader_1, image_datafield_1), ..., (image_subheader_n, image_datafield_n)
// - Each individual, standard data segment included in an NITF file, such as an IS or a GS, 
//   shall be preceded by a subheader corresponding to that data segment.
// - The NITF File header and various subheaders have two types of fields: required and conditional.

include character_sets

// The data elements in the image subheader fields provide information 
// about the image source, its identification, and characteristics 
// needed to display and interpret it properly. The image subheader field definitions 
// are detailed in TABLE 3. see. pg. 28 - 47
type image_subheader = {
    // image subheader details go here
    // image subheader presented as a user-defined record type

    // length of image subheader, see Fig. 7, pg. 9
    sh_length: int,
    im: string,
    iid1: string,
    // todo: Verify with Prashanth as IDATIM is datetime
    idatim: string,
    tgtid: string,
    iid2: string,
    // image security classification
    // todo: consider moving this to a separate type
    isclas: [byte],
    isclsy: [byte],
    isctlh: [byte],
    isrel: [byte],
    isdctp: [byte],
    isdcdt: string,         // another datetime
    isdcxm: [byte],
    isdg: [byte],
    isdgdt: string,
    iscltx: string,
    iscatp: [byte],
    iscaut: string,         // this and iscltx are user-defined free text
    iscrsn: [byte],
    issrdt: string,         // date of the source used to derive the classification of the image
    isctln: int,            // image security control number
    encryp: [byte],         // encryption
    isorce: string,         // image source
    nrows: int,             // number of significant rows in image
    ncols: int,             // number of significant columns in image
    pvtype: [byte],         // pixel value type
    irep: [byte],           // image representation
    icat: string,           // image category
    abpp: int,              // actual bits-per-pixel per band
    pjust: [byte],          // pixel justification
    icords: [byte],         // image coordinate representation
    igeolo: [byte],         // image geographic location
    nicom: int,             // number of image comments
    icomn: string,          // image comment n
    ic: [byte],             // image compression
    comrat: [byte],         // compression rate code
    nbands: int,            // number of bands
    xbands: int,            // number of multispectral bands
    // todo: verify whether these are needed in the subheader of a particular image
    irepbandn: [byte],      // n-th band representation
    isubcatn: [byte],       // n-th band subcategory
    ifcn: [byte],           // n-th band filter condition
    // more of the above in pg. 42
    isync: byte,            // image sync code
    imode: byte,            // image mode
    nbpr: int,              // number of blocks per row
    nbpc: int,              // number of blocks per column
    nppbh: int,             // number of pixels per block horizontal
    nppbv: int,             // number of pixels per block vertical
    nbpp: int,              // number of bits per pixel per band
    idlvl: int,             // image display level, BCS-N positive integer from 001 - 999
    ialvl: int,             // attachment level, BCS-N positive integer from 000 - 998
    iloc: [byte],           // image location
    imag: [byte],           // image magnification
    udidl: int,             // user-defined image data length, BCS-N positive integer 00000 or 00003 to 99999
    udofl: int,             // user-defined overflow
    udid: [byte],           // user-defined image data, DOUBLE-CHECK
    ixshdl: int,            // image extended subheader data length
    ixsofl: int,            // image extended subheader overflow
    ixshd: [byte],          // image extended subheader data, length of (ixshdl - 3), DOUBLE-CHECK
}

// todo: length of image segment, see Fig. 7, pg. 9
type image_datafield = {
    // image datafield information goes here
    df_length: int
}

// The image data mask table is a conditional data structure 
// included in the image data stream for masked images when so indicated by the IC field value
type image_datamask = {
    // todo
}

type image_segment = {
    img_sh: image_subheader,
    img_df: image_datafield
}

type image_segments = {
    // number of images, see Fig. 7, pg. 9
    n: int,
    // list of image segments
    img_segs = [image_segment]
}

format {
    // image segment non-terminal definition
    ImageSegment im {i: image_segment} :=
        {

        }
    
    ImageSegments ims {s: image_segments} := 
        {

        }
}