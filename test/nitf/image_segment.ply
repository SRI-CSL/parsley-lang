// NITF Image Segment Parsley Definition
// 
// SRI International, 2022

// Briland Notes
// -------------
// - An Image Segment (IS) supports the standard image type of data, see pg. 5 of NITF spec.
// - There can be n-Image Data Segments organized as: 
//   (image_subheader_1, image_datafield_1), ..., (image_subheader_n, image_datafield_n)
// - Each individual, standard data segment included in an NITF file, such as an IS or a GS, 
//   shall be preceded by a subheader corresponding to that data segment.
// - The NITF File header and various subheaders have two types of fields: required and conditional.

include character_sets

// The data elements in the image subheader fields provide information 
// about the image source, its identification, and characteristics 
// needed to display and interpret it properly. The image subheader field definitions 
// are detailed in TABLE 3. see. pg. 28 - 47
type image_subheader = {
    // image subheader details go here
    // image subheader presented as a user-defined record type

    // length of image subheader, see Fig. 7, pg. 9
    // sh_length: int,
    im: [byte],
    iid1: [byte],
    // todo: Verify with Prashanth as IDATIM is datetime
    idatim: [byte],
    tgtid: [byte],
    iid2: [byte],
    // image security classification
    // todo: consider moving this to a separate type
    isclas: [byte],
    isclsy: [byte],
    iscode: [byte],
    isctlh: [byte],
    isrel: [byte],
    isdctp: [byte],
    isdcdt: [byte],         // another datetime
    isdcxm: [byte],
    isdg: [byte],
    isdgdt: [byte],
    iscltx: [byte],
    iscatp: [byte],
    iscaut: [byte],         // this and iscltx are user-defined free text
    iscrsn: [byte],
    issrdt: [byte],         // date of the source used to derive the classification of the image
    isctln: [byte],            // image security control number
    encryp: [byte],         // encryption
    isorce: [byte],         // image source
    nrows: int,             // number of significant rows in image
    ncols: int,             // number of significant columns in image
    pvtype: [byte],         // pixel value type
    irep: [byte],           // image representation
    icat: [byte],           // image category
    abpp: int,              // actual bits-per-pixel per band
    pjust: [byte],          // pixel justification
    icords: [byte],         // image coordinate representation
    igeolo: [byte],         // image geographic location
    nicom: int,             // number of image comments
    icomn: string,          // image comment n
    ic: [byte],             // image compression
    comrat: [byte],         // compression rate code
    nbands: int,            // number of bands
    xbands: int,            // number of multispectral bands
    // todo: verify whether these are needed in the subheader of a particular image
    irepbandn: [byte],      // n-th band representation
    isubcatn: [byte],       // n-th band subcategory
    ifcn: [byte],           // n-th band filter condition
    // more of the above in pg. 42
    isync: byte,            // image sync code
    imode: byte,            // image mode
    nbpr: int,              // number of blocks per row
    nbpc: int,              // number of blocks per column
    nppbh: int,             // number of pixels per block horizontal
    nppbv: int,             // number of pixels per block vertical
    nbpp: int,              // number of bits per pixel per band
    idlvl: int,             // image display level, BCS-N positive integer from 001 - 999
    ialvl: int,             // attachment level, BCS-N positive integer from 000 - 998
    iloc: [byte],           // image location
    imag: [byte],           // image magnification
    udidl: int,             // user-defined image data length, BCS-N positive integer 00000 or 00003 to 99999
    udofl: int,             // user-defined overflow
    udid: [byte],           // user-defined image data, DOUBLE-CHECK
    ixshdl: int,            // image extended subheader data length
    ixsofl: int,            // image extended subheader overflow
    ixshd: [byte]           // image extended subheader data, length of (ixshdl - 3), DOUBLE-CHECK
}

// todo: length of image segment, see Fig. 7, pg. 9
type image_datafield = {
    // image datafield information goes here
    df_length: int
}

// The image data mask table is a conditional data structure 
// included in the image data stream for masked images when so indicated by the IC field value
type image_datamask = {
    // todo
}

type image_segment = {
    img_sh: image_subheader,
    img_df: image_datafield
}

type image_segments = {
    // number of images, see Fig. 7, pg. 9
    n: int,
    // list of image segments
    img_segs: [image_segment]
}

format {
    IM := !"IM"!;;
    ISCLAS := (# ["T" | "S" | "C" | "R" | "U" ] #);;
    ISDCTP := (# ["DD" | "DE" | "GD" | "GE" | "O" | "X" | "\x20"] #);;
    ISDCXM := (# ["X1" .. "X8"] | ["25X1" .. "25X9"] | "DNIO" | "\x20" #)
    ISDG := (# ["S" | "C" | "R" | "\x20"] #);;
    ISCATP := (# ["O" | "D" | "M" | "\x20"] #);;
    ISCRSN := (# ["A" .. "H"] | ["\x20"] #);;
    CCYYMMDD := (# ["00".."99"] // CC
                 ["00".."99"] // YY
                 (["0"]["0".."9"]|["1"]["0".."2"])  // MM
                 (["0"]["1".."9"] |
                  ["1" .. "2"]["0" .. "9"] |
                  ["3"]["0" .. "1"]) // DD
                 #);;
    ISSRDT := (# CCYYMMDD | ["\x20"]* #);;
    N_ROW_COL := (# ["00000001" .. "99999999"] #);;
    PVTYPE := (# [BCS_A | "INT" | "B" | "SI" | "R" | "C"] #);;

    ImageSubheader img_sub {is: image_subheader} := 
        file_part_type = IM
        image_identifier_1 = (BCS_A^10u)
        // to do
        // image_date_time =
        // target_identifier = 
        image_identifier_2 = (ECS_A^80u) // Required and BCS spaces required for the entire field, ask @Prashanth
        image_security_classification = (ISCLAS^1u)
        // image_security_classification_system =
        // image_codewords = 
        image_releasing_instructions = (ECS_A^20u)
        image_declassification_type = (ISDCTP^2u)
        // image_declassification_date = 
        image_declassification_exemption = (ISDCXM^4u)
        image_downgrade = (ISDG^1u)
        // image_downgrade_date = 
        image_classification_text = (Byte^43)
        image_classification_authority_type = (ISCATP^1u)
        image_classification_authority = (Byte^40u)
        image_classification_reason = (ISCRSN^1u)
        image_security_source_date = ISSRDT
        image_security_control_number = (ECS_A^15u)
        encryption = (BCS_N_INT_POS^1u)
        image_source = (ECS_A^42u)
        number_of_significant_rows_in_image = N_ROW_COL
        number_of_significant_cols_in_image = N_ROW_COL
        pixel_value_type = (PVTYPE^3)
        {
            img_sub.is.im   := file_part_type;
            img_sub.is.iid1 := image_identifier_1;
            // img_sub.is.idatim := image_date_time;
            // img_sub.is.tgtid := target_identifier;
            img_sub.is.iid2 := image_identifier_2;
            img_sub.is.isclas := image_security_classification;
            // img_sub.is.isclsy := image_security_classification_system;
            // img_sub.is.iscode := image_codewords;
            img_sub.is.isrel := image_releasing_instructions;
            img_sub.is.isdctp := image_declassification_type;
            // img_sub.is.isdcdt := image_declassification_date;
            img_sub.is.isdcxm := image_declassification_exemption;
            img_sub.is.isdg := image_downgrade;
            // img_sub.is.isdgdt := image_downgrade_date;
            img_sub.is.iscltx := image_classification_text;

            // to do: if this field contains and ECS space,
            // it shall imply that image classification authority type does not apply
            img_sub.is.iscatp := image_classification_authority_type;
            // to do: If this field is populated with all ECS spaces (0x20), 
            // it shall imply that no image classification authority applies.
            img_sub.is.iscaut := image_classification_authority;
            // to do: If this field contains an ECS space (0x20), 
            // it shall imply that no image classification reason applies.
            img_sub.is.iscrsn := image_classification_reason;
            img_sub.is.issrdt := image_security_source_date;
            // to do: If this field is populated with all ECS spaces (0x20), 
            // it shall imply that no image security control number applies.
            img_sub.is.isctln := image_security_control_number;
            // This field shall contain the value BCS zero (0x30) 
            // until such time as this specification is updated to define the use of other values.
            img_sub.is.encryp := encryption;
            // to do: This field shall contain a description of the source of the image. 
            // If the source of the data is classified, then the description shall be preceded by 
            // the classification, including codeword(s) contained in the NITF Field Value Registry,
            // specified in section C.2.1 Online Resources. If this field is populated with all ECS 
            // spaces (0x20), it shall imply that no image source data applies.
            img_sub.is.isorce := image_source;
            img_sub.is.nrows := number_of_significant_rows_in_image;
            img_sub.is.ncols := number_of_significant_cols_in_image;
            img_sub.is.pvtype := pixel_value_type;
        }

    // // image segment non-terminal definition
    // ImageSegment im {i: image_segment} :=
    //     {

    //     }
    
    // ImageSegments ims {s: image_segments} := 
    //     {

    //     }
}