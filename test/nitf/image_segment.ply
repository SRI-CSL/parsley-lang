// NITF Image Segment Parsley Definition
// 
// SRI International, 2022

// Briland Notes
// -------------
// - An Image Segment (IS) supports the standard image type of data, see pg. 5 of NITF spec.
// - There can be n-Image Data Segments organized as: 
//   (image_subheader_1, image_datafield_1), ..., (image_subheader_n, image_datafield_n)
// - Each individual, standard data segment included in an NITF file, such as an IS or a GS, 
//   shall be preceded by a subheader corresponding to that data segment.
// - The NITF File header and various subheaders have two types of fields: required and conditional.

include character_sets

// The data elements in the image subheader fields provide information 
// about the image source, its identification, and characteristics 
// needed to display and interpret it properly. The image subheader field definitions 
// are detailed in TABLE 3. see. pg. 28 - 47
type image_subheader = {
    // image subheader details go here
    // image subheader presented as a user-defined record type

    // length of image subheader, see Fig. 7, pg. 9
    // sh_length: int,
    im: [byte],
    iid1: [byte],
    // todo: Verify with Prashanth as IDATIM is datetime
    idatim: [byte],
    tgtid: [byte],
    iid2: [byte],
    // image security classification
    // todo: consider moving this to a separate type
    isclas: [byte],
    isclsy: [byte],
    iscode: [byte],
    isctlh: [byte],
    isrel: [byte],
    isdctp: [byte],
    isdcdt: [byte],         // another datetime
    isdcxm: [byte],
    isdg: [byte],
    isdgdt: [byte],
    iscltx: [byte],
    iscatp: [byte],
    iscaut: [byte],         // this and iscltx are user-defined free text
    iscrsn: [byte],
    issrdt: [byte],         // date of the source used to derive the classification of the image
    isctln: [byte],            // image security control number
    encryp: [byte],         // encryption
    isorce: [byte],         // image source
    nrows: int,             // number of significant rows in image
    ncols: int,             // number of significant columns in image
    pvtype: [byte],         // pixel value type
    irep: [byte],           // image representation
    icat: [byte],           // image category
    abpp: int,              // actual bits-per-pixel per band
    pjust: [byte],          // pixel justification
    icords: [byte],         // image coordinate representation
    igeolo: [byte],         // image geographic location
    nicom: int,             // number of image comments
    icomn: string,          // image comment n
    ic: [byte],             // image compression
    comrat: [byte],         // compression rate code
    nbands: int,            // number of bands
    xbands: int,            // number of multispectral bands
    // todo: verify whether these are needed in the subheader of a particular image
    irepbandn: [byte],      // n-th band representation
    isubcatn: [byte],       // n-th band subcategory
    ifcn: [byte],           // n-th band filter condition
    // more of the above in pg. 42
    isync: [byte],          // image sync code
    imode: [byte],          // image mode
    nbpr: [byte],              // number of blocks per row
    nbpc: [byte],              // number of blocks per column
    nppbh: [byte],             // number of pixels per block horizontal
    nppbv: [byte],             // number of pixels per block vertical
    nbpp: [byte],              // number of bits per pixel per band
    idlvl: [byte],             // image display level, BCS-N positive integer from 001 - 999
    ialvl: [byte],             // attachment level, BCS-N positive integer from 000 - 998
    iloc: [byte],           // image location
    imag: [byte],           // image magnification
    udidl: [byte],             // user-defined image data length, BCS-N positive integer 00000 or 00003 to 99999
    udofl: [byte],             // user-defined overflow
    udid: [byte],           // user-defined image data, DOUBLE-CHECK
    ixshdl: [byte],            // image extended subheader data length
    ixsofl: [byte],            // image extended subheader overflow
    ixshd: [byte]           // image extended subheader data, length of (ixshdl - 3), DOUBLE-CHECK
}

// todo: length of image segment, see Fig. 7, pg. 9
type image_datafield = {
    // image datafield information goes here
    df_length: int
}

// The image data mask table is a conditional data structure 
// included in the image data stream for masked images when so indicated by the IC field value
type image_datamask = {
    // todo
}

type image_segment = {
    img_sh: image_subheader,
    img_df: image_datafield
}

type image_segments = {
    // number of images, see Fig. 7, pg. 9
    n: int,
    // list of image segments
    img_segs: [image_segment]
}

format {
    IM := !"IM"!;;
    ISCLAS := (# ["T" | "S" | "C" | "R" | "U" ] #);;
    ISDCTP := (# ["DD" | "DE" | "GD" | "GE" | "O" | "X" | "\x20"] #);;
    ISDCXM := (# ["X1" .. "X8"] | ["25X1" .. "25X9"] | "DNIO" | "\x20" #);;
    ISDG := (# ["S" | "C" | "R" | "\x20"] #);;
    ISCATP := (# ["O" | "D" | "M" | "\x20"] #);;
    ISCRSN := (# ["A" .. "H"] | ["\x20"] #);;
    CCYYMMDD := (# ["00".."99"] // CC
                 ["00".."99"] // YY
                 (["0"]["0".."9"]|["1"]["0".."2"])  // MM
                 (["0"]["1".."9"] |
                  ["1" .. "2"]["0" .. "9"] |
                  ["3"]["0" .. "1"]) // DD
                 #);;
    ISSRDT := (# CCYYMMDD | ["\x20"]* #);;
    N_ROW_COL := (# ["00000001" .. "99999999"] #);;
    PVTYPE := (# [BCS_A | "INT" | "B" | "SI" | "R" | "C"] #);;
    IREP := (# [BCS_A | "MONO" | "RGB" | "RGB/LUT" | "MULTI" | "NODISPLY" | "NVECTOR" | "POLAR" | "VPH" | "YCbCr601"] #);;
    ABPP := (# ["01" .. "96"] #);;
    PJUST := (# ["R" | "L"] #);;
    ICORDS := (#["U" | "G" | "N" | "S" | "P" | "D" | "\x20"] #);;
    NICOM := (# ["0" .. "9"] #);;
    IC := (# ["NC" | "NM" | "I1"] | ["C1" .. "C8"] | ["M1" .. "M8"] | ["CB" | "MB" | "C9" | "M9" | "CA" | "MA"] #);;
    XBANDS := (# ["00010" .. "99999"] #);;
    IMODE := (# ["B" | "P" | "R" | "S"] | ["T" | "D" | "E" | "F" | "X" | "Z"] #);;
    NBP := (# ["0001" .. "9999"] #);;
    NPP := (# ["0000"] | ["0001" .. "8192"] #);;
    IDLVL := (# ["001" .. "999"] #);;
    IALVL := (# ["000" .. "998"] #);;
    UDIDL := (# ["00000"] | ["00003" .. "99999"] #);;

    ImageSubheader img_sub {is: image_subheader} := 
        file_part_type = IM
        image_identifier_1 = (BCS_A^10u)
        // to do
        // image_date_time =
        // target_identifier = 
        image_identifier_2 = (ECS_A^80u) // Required and BCS spaces required for the entire field, ask @Prashanth
        image_security_classification = (ISCLAS^1u)
        // image_security_classification_system =
        // image_codewords = 
        image_releasing_instructions = (ECS_A^20u)
        image_declassification_type = (ISDCTP^2u)
        // image_declassification_date = 
        image_declassification_exemption = (ISDCXM^4u)
        image_downgrade = (ISDG^1u)
        // image_downgrade_date = 
        image_classification_text = (Byte^43u)
        image_classification_authority_type = (ISCATP^1u)
        image_classification_authority = (Byte^40u)
        image_classification_reason = (ISCRSN^1u)
        image_security_source_date = ISSRDT
        image_security_control_number = (ECS_A^15u)
        encryption = (BCS_N_INT_POS^1u)
        image_source = (ECS_A^42u)
        number_of_significant_rows_in_image = N_ROW_COL
        number_of_significant_cols_in_image = N_ROW_COL
        pixel_value_type = (PVTYPE^3u)
        image_representation = (IREP^8u)
        image_category = (BCS_A^8u)
        actual_bit_per_pixel_per_band = (ABPP^2u)
        pixel_justification = (PJUST^1u)
        image_coordinate_representation = (ICORDS^1u)
        // image_geographic_location =
        number_of_image_comments = (NICOM^1u)
        image_comment_n = (ECS_A^80u)
        image_compression = (IC^2u)
        // ASK: pg. 37: the field (COMRAT) is conditional based on the values of image compression (IC)
        // compression_rate_code = 
        number_of_bands = (NICOM^1u)
        number_of_multispectral_bands = (XBANDS^5u)
        // image sync code field is reserved for future use.
        // This field shall contain BCS zero (0x30). see pg. 42 of NITF spec
        image_sync_code = "\x30"
        image_mode = (IMODE^1u)
        number_of_blocks_per_row = (NBP^4u)
        number_of_blocks_per_col = (NBP^4u)
        number_of_pixels_per_block_horizontal = (NPP^4u)
        number_of_pixels_per_block_vertical = (NPP^4u)
        number_of_bits_per_pixel_per_band = (ABPP^2u)
        image_display_level = (IDLVL^3u)
        attachment_level = (IALVL^3u)
        image_location = (BCS_N^10u)
        image_magnification = (BCS_A^4u)
        user_defined_image_data_length = (UDIDL^5u)
        // conditional on UDIDL
        // user_defined_overflow =
        // user_defined_image_data = 
        image_extended_subheader_data_length = (UDIDL^5u)
        // conditional on IXSHDL
        // image_extended_subheader_overflow =
        // image_extended_subheader_data = 
        {
            img_sub.is.im   := file_part_type;
            
            img_sub.is.iid1 := image_identifier_1;
            
            // img_sub.is.idatim := image_date_time;
            
            // img_sub.is.tgtid := target_identifier;
            
            img_sub.is.iid2 := image_identifier_2;
            
            img_sub.is.isclas := image_security_classification;
            
            // img_sub.is.isclsy := image_security_classification_system;
            
            // img_sub.is.iscode := image_codewords;
            
            img_sub.is.isrel := image_releasing_instructions;
            
            img_sub.is.isdctp := image_declassification_type;
            
            // img_sub.is.isdcdt := image_declassification_date;
            
            img_sub.is.isdcxm := image_declassification_exemption;
            
            img_sub.is.isdg := image_downgrade;
            
            // img_sub.is.isdgdt := image_downgrade_date;
            
            img_sub.is.iscltx := image_classification_text;

            // to do: if this field contains and ECS space,
            // it shall imply that image classification authority type does not apply
            img_sub.is.iscatp := image_classification_authority_type;
            
            // to do: If this field is populated with all ECS spaces (0x20), 
            // it shall imply that no image classification authority applies.
            img_sub.is.iscaut := image_classification_authority;
            
            // to do: If this field contains an ECS space (0x20), 
            // it shall imply that no image classification reason applies.
            img_sub.is.iscrsn := image_classification_reason;
            
            img_sub.is.issrdt := image_security_source_date;
            
            // to do: If this field is populated with all ECS spaces (0x20), 
            // it shall imply that no image security control number applies.
            img_sub.is.isctln := image_security_control_number;
            
            // This field shall contain the value BCS zero (0x30) 
            // until such time as this specification is updated to define the use of other values.
            img_sub.is.encryp := encryption;
            
            // to do: This field shall contain a description of the source of the image. 
            // If the source of the data is classified, then the description shall be preceded by 
            // the classification, including codeword(s) contained in the NITF Field Value Registry,
            // specified in section C.2.1 Online Resources. If this field is populated with all ECS 
            // spaces (0x20), it shall imply that no image source data applies.
            img_sub.is.isorce := image_source;
            
            img_sub.is.nrows := number_of_significant_rows_in_image;
            
            img_sub.is.ncols := number_of_significant_cols_in_image;
            
            img_sub.is.pvtype := pixel_value_type;

            // This field should be used in conjunction with the IREPBANDn field to interpret
            // the processing required to display each band in the image.
            img_sub.is.irep := image_representation;

            // to do: refer to pg. 34 for additional conditions
            img_sub.is.icat := image_category;

            // to do: The default number of significant bits to be used is the value contained in NBPP.
            img_sub.is.abpp := actual_bits_per_pixel_per_band;
            
            // to do: default is R
            img_sub.is.pjust := pixel_justification;

            img_sub.is.icords := image_coordinate_representation;

            // img_sub.is.igeolo := image_geographic_location;

            img_sub.is.nicom := number_of_image_comments;

            // to do: Check with Prashanth whether we can define this 
            // as a matrix [idx_i][comment_img_i]
            for i .. number_of_image_comments {
                img_sub.is.icomn := image_comment_n
            }

            img_sub.is.ic := image_compression;

            img_sub.is.nbands := number_of_bands;

            img_sub.is.xbands := number_of_multispectral_bands;

            img_sub.is.isync := image_sync_code;

            img_sub.is.imode := image_mode;

            img_sub.is.nbpr := number_of_blocks_per_row;

            img_sub.is.nbpc := number_of_blocks_per_col;

            img_sub.is.nppbh := number_of_pixels_per_block_horizontal;

            img_sub.is.nppbv := number_of_pixels_per_block_vertical;

            img_sub.is.nbpp := number_of_bits_per_pixel_per_band;

            img_sub.is.idlvl := image_display_level;

            img_sub.is.ialvl := attachment_level;

            img_sub.is.iloc := image_location;

            img_sub.is.imag := image_magnification;

            img_sub.is.udidl := user_defined_image_data_length;

            // img_sub.is.udofl := user_defined_overflow;

            // img_sub.is.udid := user_defined_image_data;

            img_sub.is.ixshdl := image_extended_subheader_data_length;

            // img_sub.is.ixsofl := image_extended_subheader_overflow;

            // img_sub.is.ixshd := image_extended_subheader_data;

        }

    // // image segment non-terminal definition
    // ImageSegment im {i: image_segment} :=
    //     {

    //     }
    
    // ImageSegments ims {s: image_segments} := 
    //     {

    //     }
}