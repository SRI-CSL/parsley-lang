// NITF Image Segment Parsley Definition
// 
// SRI International, 2022

// Briland Notes
// -------------
// - An Image Segment (IS) supports the standard image type of data, see pg. 5 of NITF spec.
// - There can be n-Image Data Segments organized as: 
//   (image_subheader_1, image_datafield_1), ..., (image_subheader_n, image_datafield_n)
// - Each individual, standard data segment included in an NITF file, such as an IS or a GS, 
//   shall be preceded by a subheader corresponding to that data segment.
// - The NITF File header and various subheaders have two types of fields: required and conditional.

include character_sets

// The data elements in the image subheader fields provide information 
// about the image source, its identification, and characteristics 
// needed to display and interpret it properly. The image subheader field definitions 
// are detailed in TABLE 3. see. pg. 28 - 47
type image_subheader = {
    // image subheader details go here
    // image subheader presented as a user-defined record type

    // length of image subheader, see Fig. 7, pg. 9
    // sh_length: int,
    im: [byte],
    iid1: [byte],
    // todo: Verify with Prashanth as IDATIM is datetime
    idatim: [byte],
    tgtid: [byte],
    iid2: [byte],
    // image security classification
    // todo: consider moving this to a separate type
    isclas: [byte],
    isclsy: [byte],
    iscode: [byte],
    isctlh: [byte],
    isrel: [byte],
    isdctp: [byte],
    isdcdt: [byte],         // another datetime
    isdcxm: [byte],
    isdg: [byte],
    isdgdt: [byte],
    iscltx: string,
    iscatp: [byte],
    iscaut: string,         // this and iscltx are user-defined free text
    iscrsn: [byte],
    issrdt: string,         // date of the source used to derive the classification of the image
    isctln: int,            // image security control number
    encryp: [byte],         // encryption
    isorce: string,         // image source
    nrows: int,             // number of significant rows in image
    ncols: int,             // number of significant columns in image
    pvtype: [byte],         // pixel value type
    irep: [byte],           // image representation
    icat: string,           // image category
    abpp: int,              // actual bits-per-pixel per band
    pjust: [byte],          // pixel justification
    icords: [byte],         // image coordinate representation
    igeolo: [byte],         // image geographic location
    nicom: int,             // number of image comments
    icomn: string,          // image comment n
    ic: [byte],             // image compression
    comrat: [byte],         // compression rate code
    nbands: int,            // number of bands
    xbands: int,            // number of multispectral bands
    // todo: verify whether these are needed in the subheader of a particular image
    irepbandn: [byte],      // n-th band representation
    isubcatn: [byte],       // n-th band subcategory
    ifcn: [byte],           // n-th band filter condition
    // more of the above in pg. 42
    isync: byte,            // image sync code
    imode: byte,            // image mode
    nbpr: int,              // number of blocks per row
    nbpc: int,              // number of blocks per column
    nppbh: int,             // number of pixels per block horizontal
    nppbv: int,             // number of pixels per block vertical
    nbpp: int,              // number of bits per pixel per band
    idlvl: int,             // image display level, BCS-N positive integer from 001 - 999
    ialvl: int,             // attachment level, BCS-N positive integer from 000 - 998
    iloc: [byte],           // image location
    imag: [byte],           // image magnification
    udidl: int,             // user-defined image data length, BCS-N positive integer 00000 or 00003 to 99999
    udofl: int,             // user-defined overflow
    udid: [byte],           // user-defined image data, DOUBLE-CHECK
    ixshdl: int,            // image extended subheader data length
    ixsofl: int,            // image extended subheader overflow
    ixshd: [byte]           // image extended subheader data, length of (ixshdl - 3), DOUBLE-CHECK
}

// todo: length of image segment, see Fig. 7, pg. 9
type image_datafield = {
    // image datafield information goes here
    df_length: int
}

// The image data mask table is a conditional data structure 
// included in the image data stream for masked images when so indicated by the IC field value
type image_datamask = {
    // todo
}

type image_segment = {
    img_sh: image_subheader,
    img_df: image_datafield
}

type image_segments = {
    // number of images, see Fig. 7, pg. 9
    n: int,
    // list of image segments
    img_segs: [image_segment]
}

format {
    IM := !"IM"!;;
    ISCLAS := (# ["T" | "S" | "C" | "R" | "U" ] #);;
    ISDCTP := (# ["DD" | "DE" | "GD" | "GE" | "O" | "X" | "\x20"] #);;
    ISDCXM := (# ["X1" .. "X8"] | ["25X1" .. "25X9"] | "DNIO" | "\x20" #)
    ISDG := (# ["S" | "C" | "R" | "\x20"] #)

    ImageSubheader img_sub {is: image_subheader} := 
        file_part_type = IM
        image_identifier_1 = (BCS_A^10u)
        // to do
        // image_date_time =
        // target_identifier = 
        image_identifier_2 = (ECS_A^80u) // Required and BCS spaces required for the entire field, ask @Prashanth
        image_security_classification = (ISCLAS^1u)
        // image_security_classification_system =
        // image_codewords = 
        image_releasing_instructions = (ECS_A^20u)
        image_declassification_type = (ISDCTP^2u)
        // image_declassification_date = 
        image_declassification_exemption = (ISDCXM^4u)
        image_downgrade = (ISDG^1u)
        {
            img_sub.is.im   := file_part_type;
            img_sub.is.iid1 := image_identifier_1;
            // img_sub.is.idatim := image_date_time;
            // img_sub.is.tgtid := target_identifier;
            img_sub.is.iid2 := image_identifier_2;
            img_sub.is.isclas := image_security_classification;
            // img_sub.is.isclsy := image_security_classification_system;
            // img_sub.is.iscode := image_codewords;
            img_sub.is.isrel := image_releasing_instructions;
            img_sub.is.isdctp := image_declassification_type;
            // img_sub.is.isdcdt := image_declassification_date;
            img_sub.is.isdcxm := image_declassification_exemption;
            img_sub.is.isdg := image_downgrade;
        }

    // // image segment non-terminal definition
    // ImageSegment im {i: image_segment} :=
    //     {

    //     }
    
    // ImageSegments ims {s: image_segments} := 
    //     {

    //     }
}