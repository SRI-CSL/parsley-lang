// NITF Image Segment Parsley Definition
// 
// SRI International, 2022

// Briland Notes
// -------------
// - An Image Segment (IS) supports the standard image type of data, see pg. 5 of NITF spec.
// - There can be n-Image Data Segments organized as: 
//   (image_subheader_1, image_datafield_1), ..., (image_subheader_n, image_datafield_n)
// - Each individual, standard data segment included in an NITF file, such as an IS or a GS, 
//   shall be preceded by a subheader corresponding to that data segment.
// - The NITF File header and various subheaders have two types of fields: required and conditional.

// The data elements in the image subheader fields provide information 
// about the image source, its identification, and characteristics 
// needed to display and interpret it properly. The image subheader field definitions 
// are detailed in TABLE 3. see. pg. 28 - 47
type image_subheader = {
    // image subheader details go here
    // image subheader presented as a user-defined record type

    // length of image subheader, see Fig. 7, pg. 9
    sh_length: int,
    im: string,
    iid1: string,
    // todo: Verify with Prashanth as IDATIM is datetime
    idatim: string,
    tgtid: string,
    iid2: string,
    // image security classification
    // todo: consider moving this to a separate type
    isclas: [byte],
    isclsy: [byte],
    isctlh: [byte],
    isrel: [string],
    isdctp: [byte],
    isdcdt: string, // another datetime
    isdcxm: [byte],
    isdg: [byte],
    isdgdt: string,
    iscltx: string,
    iscatp: [byte],
    iscaut: string, // this and iscltx are user-defined free text
    iscrsn: [byte],
    issrdt: string, // date of the source used to derive the classification of the image
    isctln: int,    // image security control number
    encryp: [byte], // encryption
    isorce: string, // image source
    nrows: int,     // number of significant rows in image
    ncols: int,     // number of significant columns in image
    pvtype: [byte], // pixel value type
    irep: string,   // image representation
    icat: string,   // image category
    abpp: int,      // actual bits-per-pixel per band
    pjust: [byte],  // pixel justification
    icords: [byte], // image coordinate representation
    igeolo: [byte], // image geographic location
    nicom: int,     // number of image comments
    icomn: string,  // image comment n
    ic: [byte],     // image compression
}

// todo: length of image segment, see Fig. 7, pg. 9
type image_datafield = {
    // image datafield information goes here
    df_length: int
}

type image_segment = {
    img_sh: image_subheader,
    img_df: image_datafield
}

type image_segments = {
    // number of images, see Fig. 7, pg. 9
    n: int,
    // list of image segments
    img_segs = [image_segment]
}

format {
    // image segment non-terminal definition
    ImageSegment im {i: image_segment} :=
        {

        }
    
    ImageSegments ims {s: image_segments} := 
        {

        }
}