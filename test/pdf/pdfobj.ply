// Compound object syntax.

use pdfprim

// The expression sublanguage for semantic actions has access to a
// Parsley standard library, which contains maps, lists, vectors,
// sets, etc.  These will be used below.

// The type of the basic COS object.
type basic_obj =
 | Dict of map<string, basic_obj>
 | Array of [basic_obj]
 | Stream of (map<string, basic_obj>, [byte])
 | Reference of (int, int)
 | Boolean of bool
 | Real of double
 | Integer of int
 | String of [byte]
 | Name of string
 | Null

// The type of the indirect object.
type indirect_obj =
 { oid: int,
   ogen: int,
   obj: basic_obj }

// The parsing context maps object identifers to indirect objects.
type parse_ctxt = map<(int, int), basic_obj>

// Type abbreviation for the dictionary type.
type dict = map<string, basic_obj>

format {

  // attribute specification that governs the next non-terminal
  // definition.  the whitespace attribute only controls implicit
  // content between the entities of the production, and not within
  // them.

  // Whitespace is needed to separate these tokens.
  #[whitespace(Whitespace:allow_empty=false)]
  Reference r {id: int, gen: int} :=
    n=Integer [ n.i >  0 ]
    g=Integer [ g.i >= 0 ]
    !"R"!
    { r.id  := n.i;
      r.gen := g.i }
  ;;

  // Whitespace is not needed to demarcate the objects.
  #[whitespace(Whitespace:allow_empty=true)]
  Array a {a: [basic_obj]} :=
    !"["!
    ( o=PDFObj
      { a.a := o.o :: a.a }
    )*
    !"]"!
    { a.a := List.rev(a.a) } // restore original ordering
  ;;

  #[whitespace(Whitespace:allow_empty=true)]
  Dict d {d: dict} :=
    // Temporary variable introduced while parsing this production.
    (| s: set<string> := Set.empty |)

    !"<<"!
    ( n=Name
      [ !Set.mem(s, n.nm) ]
      o=PDFObj
      { d.d := Map.add(d.d, n.nm, o.o);
        s := Set.add(s, n.nm) }
    )*
    !">>"!
  ;;

  // Note that the PDFObj parsing rule does not parse Streams.
  PDFObj p {o: basic_obj} :=
    d=Dict
    { p.o := basic_obj::Dict(d.d) }
  ;
    a=Array
    { p.o := basic_obj::Array(a.a) }
  ;
    r=Reference
    { p.o := basic_obj::Reference((r.id, r.gen)) }
  ;
    b=Boolean
    { p.o := basic_obj::Boolean(b.b) }
  ;
    r=Real
    { p.o := basic_obj::Real(r.r) }
  ;
    i=Integer
    { p.o := basic_obj::Integer(i.i) }
  ;
    s=String
    { p.o := basic_obj::String(s.s) }
  ;
    n=Name
    { p.o := basic_obj::Name(n.nm) }
  ;
    n=Null
    { p.o := basic_obj::Null() }

  ;;

  #[whitespace(Whitespace:allow_empty=true)]
  Stream s {dict: dict, stream: [byte]} :=
    d=Dict
    [ let key = String.of_bytes_unsafe("Length") in
      Map.mem(d.d, key)
      && Map.find_unsafe(d.d, key) ~~ basic_obj::Integer ]
    len={ ;;
          let key = String.of_bytes_unsafe("Length") in
          let basic_obj::Integer(len) = Map.find_unsafe(d.d, key) in
          len }
    rs=RawStream<len = len>
    { s.dict   := d.d;
      s.stream := rs.bytes }
  ;;

  // Indirect object parsers get an inherited attribute of the current
  // context, which contains the indirect objects parsed so far.  This
  // is used to forbid duplicates.
  #[whitespace(Whitespace:allow_empty=true)]
  Indirect i (ctxt: parse_ctxt)
             {indirect_obj} :=
    n=Integer [ n.i >  0 ]
    g=Integer [ g.i >= 0 ]
    [ !Map.mem(ctxt, (n.i, g.i)) ] // Forbid duplicate definition.

    !"obj"!
    // Parse the basic object.  Note the special rule for parsing
    // Streams, since they can only be indirect objects.
    ( s=Stream { i.obj := basic_obj::Stream((s.dict, s.stream)) }
    | o=PDFObj { i.obj := o.o }
    )
    !"endobj"!

    // Set the identifiers, and register the object in the context.
    { i.oid  := n.i;
      i.ogen := g.i;
      ctxt   := Map.add(ctxt, (n.i, g.i), i.obj) }

}
