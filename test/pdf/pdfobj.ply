// Compound object syntax.

use pdfprim:{
  Name, NameT, Integer, IntegerT, Real, RealT, Boolean, BooleanT,
  Null, NullT, RawStream, RawStreamT,
  Comment
}

// Dummy map definition (to be defined in prelude, but here until
// modules and backend-syntax work).
type map('a, 'b) = [('a, 'b)]

// Since we are using the PDFObj non-terminal below before its
// definition, we need to declare it.
nterm {PDFObj}

// The expression sublanguage for semantic actions has access to a
// Parsley standard library, which contains maps, lists, vectors,
// sets, etc.  These will be used below.

// This maps object identifiers to their objects.
type obj_ctxt = map<(int, int), indirectT>

type obj_type =
   Dict of dictT
 | Array of arrayT
 | Stream of streamT
 | Reference of referenceT
 | Boolean of booleanT
 | Real of realT
 | Integer of integerT
 | String of stringT
 | Name of nameT
 | Null

format PDFObj {

  // attribute specification that governs the next non-terminal
  // definition.  the whitespace attribute only controls implicit
  // content between the entities of the production, and not within
  // them.
  [whitespace(Whitespace<allow_empty=true>)]

  // '$typeof' is a Parsley convenience construct that substitutes the
  // type of the specified attribute.

  Dict d (ctxt : obj_ctxt) { val : map<$typeof(Name.val), obj_type> } :=
    // Temporary variable introduced while parsing this production.
    (| s : set<$typeof(Name.val)> |)

    "<<"
    ( n=Name
      [ !s.contains(n.val) ]
      o=PDFObj<ctxt = d.ctxt>
      { d.val[n.val] := o;
        s := s.add(n.val) }
    )*
    ">>"
  ;;

  [whitespace(Whitespace<allow_empty=true>)]
  Array a (ctxt : obj_ctxt) { val : [obj_type] } :=
    "["
    ( o=PDFObj<ctxt = a.ctxt>
      { a := a.val.append(o) }
    )*
    "]"
  ;;

  [whitespace(Whitespace<allow_empty=true>)]
  Reference r { id : int, gen : int } :=
    n=Integer [ n.val >  0 ]
    g=Integer [ g.val >= 0 ]
    "R"
    { r.id  := n.val;
      r.gen := g.val }
  ;;

  [whitespace(Whitespace<allow_empty=true>)]
  Stream s (ctxt : obj_ctxt)
           { dict : $typeof(Dict), stream : $typeof(RawStream) }
  :=
    d=Dict<ctxt=s.ctxt>
    s=RawStream
    [ d.val.contains("Length") && d.val["Length"] ~~ obj_type::Integer ]
    [ let i = d.val["Length"] as obj_type::Integer in
      s.val.length() = i.val ]
    { dict   := d;
      stream := s }
  ;;

   // Note that the PDFObj parsing rule does not parse Streams.
  PDFObj o (ctxt : obj_ctxt) { val : obj_type } :=
    d=Dict<ctxt = o.ctxt>
    { val := obj_type::Dict(d) }
  ;
    a=Array<ctxt = o.ctxt>
    { val := obj_type::Array(a) }
  ;
    r=ReferenceObj
    { val := obj_type::Reference(r) }
  ;
    b=Boolean
    { val := obj_type::Boolean(b) }
  ;
    r=Real
    { val := obj_type::Real(r) }
  ;
    i=Integer
    { val := obj_type::Integer(i) }
  ;
    s=String
    { val := obj_type::String(s) }
  ;
    n=Name
    { val := obj_type::Name(n) }
  ;
    n=Null
    { val := obj_type::Null() }
  ;;

  // Note the special rule for parsing Streams, since they can only be
  // indirect objects.
  [whitespace(Whitespace<allow_empty=true>)]
  Indirect i (ctxt : obj_ctxt)
             { id : int, gen : int, obj : obj_type }
  :=
    n=Integer [ n.val >  0 ]
    g=Integer [ g.val >= 0 ]
    [ !i.ctxt.contains((n.val, g.val)) ] // Forbid duplicate definition
    "obj"
      ( s=Stream { i.obj := obj_type::Stream(s) }
      | o=PDFObj { i.obj := o }
      )
    "endobj"
    { i.id  := n;
      i.gen := g;
      // register the object in the context
      i.ctxt[(n.val, g.val)] := i.obj }

}
