// Compound object syntax.

use pdfprim:{
  Name, nameT, Integer, integerT, Real, realT, Boolean, booleanT,
  Null, RawStream, rawStreamT,
  Comment
}

// Dummy map definition (to be defined in prelude, but here until
// modules and backend-syntax work).
type map('a, 'b) = [('a, 'b)]

// Since we are using the PDFObj non-terminal below before its
// definition, we need to declare it.
nterm {PDFObj}

// The expression sublanguage for semantic actions has access to a
// Parsley standard library, which contains maps, lists, vectors,
// sets, etc.  These will be used below.

// This maps object identifiers to their objects.
type obj_ctxt = map<(int, int), indirectT>

type obj_type =
   Dict of dictT
 | Array of arrayT
 | Stream of streamT
 | Reference of referenceT
 | Boolean of booleanT
 | Real of realT
 | Integer of integerT
 | String of stringT
 | Name of nameT
 | Null


format {

  // attribute specification that governs the next non-terminal
  // definition.  the whitespace attribute only controls implicit
  // content between the entities of the production, and not within
  // them.
  #[whitespace(Whitespace:allow_empty=true)]
  Dict d {val : map<string, obj_type>} :=
    // Temporary variable introduced while parsing this production.
    (| s : set<string> |)

    "<<"
    ( n=Name
      [ !s.contains(n.val) ]
      o=PDFObj
      { d.val[n.val] := o;
        s := Set.add(s, n.val) }
    )*
    ">>"
  ;;

  #[whitespace(Whitespace:allow_empty=true)]
  Array a {val : [obj_type]} :=
    "["
    ( o=PDFObj
      { a.val := List.append(a.val, o) }
    )*
    "]"
  ;;

  #[whitespace(Whitespace:allow_empty=true)]
  Reference r {id : int, gen : int} :=
    n=Integer [ n.val >  0 ]
    g=Integer [ g.val >= 0 ]
    "R"
    { r.id  := n.val;
      r.gen := g.val }
  ;;

  #[whitespace(Whitespace:allow_empty=true)]
  Stream s {dict : dictT, stream : [byte]} :=
    d=Dict
    s=RawStream
    [ d.val.contains("Length") && d.val["Length"] ~~ obj_type::Integer ]
    [ (case d.val["Length"] of
       | obj::Integer(i) -> s.val.length() = i.val
       | _               -> false
      )
    ]
    { dict   := d;
      stream := s.bytes }
  ;;

  // Note that the PDFObj parsing rule does not parse Streams.
  PDFObj {val : obj_type} :=
    d=Dict
    { val := obj_type::Dict(d) }
  ;
    a=Array
    { val := obj_type::Array(a) }
  ;
    r=ReferenceObj
    { val := obj_type::Reference(r) }
  ;
    b=Boolean
    { val := obj_type::Boolean(b) }
  ;
    r=Real
    { val := obj_type::Real(r) }
  ;
    i=Integer
    { val := obj_type::Integer(i) }
  ;
    s=String
    { val := obj_type::String(s) }
  ;
    n=Name
    { val := obj_type::Name(n) }
  ;
    n=Null
    { val := obj_type::Null() }
  ;;

  // Indirect object parsers get an inherited attribute of the current
  // context, which contains the indirect objects parsed so far.
  // This is used to forbid duplicates.
  #[whitespace(Whitespace:allow_empty=true)]
  Indirect i (ctxt : obj_ctxt)
             {id : int, gen : int, obj : obj_type}
  :=
    n=Integer [ n.val >  0 ]
    g=Integer [ g.val >= 0 ]
    [ !i.ctxt.contains((n.val, g.val)) ] // Forbid duplicate definition.
    "obj"
      // Note the special rule for parsing Streams, since they can only be
      // indirect objects.
      ( s=Stream { i.obj := obj_type::Stream(s) }
      | o=PDFObj { i.obj := o }
      )
    "endobj"
    { i.id  := n;
      i.gen := g;
      // register the object in the context
      i.ctxt := Map.extend(i.ctxt, (n.val, g.val), i.obj) }
}
