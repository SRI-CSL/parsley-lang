// Compound object syntax.

use pdfprim
use pdfstream

// The expression sublanguage for semantic actions has access to a
// Parsley standard library, which contains maps, lists, vectors,
// sets, etc.  These will be used below.

// The type of the basic COS object.
type basic_obj =
 | Dict of map<string, basic_obj>
 | Array of [basic_obj]
 | Stream of (map<string, basic_obj>, [byte])
 | Reference of (int, int)
 | Boolean of bool
 | Real of double
 | Integer of int
 | String of [byte]
 | Name of string
 | Null

// Corresponding object kinds
type obj_kind = 
  | Dict
  | Array
  | Stream
  | Reference
  | Boolean
  | Real
  | Integer
  | String
  | Name
  | Null

// The type of the indirect object.
type indirect_obj =
 { oid: int,
   ogen: int,
   obj: basic_obj }

// The parsing context maps object identifers to indirect objects.
type parse_ctxt = map<(int, int), basic_obj>

// Type abbreviation for the dictionary type.
type dict = map<string, basic_obj>

// checks whether obj is of kind obj_kind
fun check_obj_kind(obj: basic_obj, kind: obj_kind) -> bool = {
  (case kind of 
    | obj_kind::Dict -> obj ~~ basic_obj::Dict
    | obj_kind::Integer -> obj ~~ basic_obj::Integer
    | obj_kind::Array -> obj ~~ basic_obj::Array
    | obj_kind::Stream -> obj ~~ basic_obj::Stream
    | obj_kind::Reference -> obj ~~ basic_obj::Reference
    | obj_kind::Boolean -> obj ~~ basic_obj::Boolean
    | obj_kind::Real -> obj ~~ basic_obj::Real
    | obj_kind::Integer -> obj ~~ basic_obj::Integer
    | obj_kind::String -> obj ~~ basic_obj::String
    | obj_kind::Name -> obj ~~ basic_obj::Name
    | obj_kind::Null  -> obj ~~ basic_obj::Null)
}

format {

  // Decorators that annotate non-terminal definitions are encosed
  // within '#[' and ']', and are placed immediately before the
  // definition.  One such decorator defines the whitespace handling
  // for the definition.
  //
  // The whitespace decorator only controls implicit content between
  // the entities of the production rules, and not within them.

  // Whitespace is needed to separate these tokens.  The decorator uses the
  // Whitespace non-terminal defined in pdfprim.
  #[whitespace(Whitespace:allow_empty=false)]
  Reference r {id: int, gen: int} :=
    n=Integer [ n.i >  0 ]
    g=Integer [ g.i >= 0 ]
    !"R"!
    { r.id  := n.i;
      r.gen := g.i }
  ;;

  // Whitespace is not needed to demarcate the objects.
  #[whitespace(Whitespace:allow_empty=true)]
  Array a {a: [basic_obj] := []} :=
    !"["!
    ( o=PDFObj
      { a.a := o.o :: a.a }
    )*
    !"]"!
    { a.a := List.rev(a.a) } // restore original ordering
  ;;

  #[whitespace(Whitespace:allow_empty=true)]
  Dict d {d: dict} :=
    // Temporary variable introduced while parsing this production.
    (| s: set<string> := Set.empty |)
    { d.d := Map.empty }
    !"<<"!
    ( n=Name
      [ !Set.mem(s, n.nm) ]
      o=PDFObj
      { d.d := Map.add(d.d, n.nm, o.o);
        s := Set.add(s, n.nm) }
    )*
    !">>"!
  ;;

  // Note that the PDFObj parsing rule does not parse Streams, since
  // those are indirect objects.  The rule ordering here matters.  In
  // particular, the rule for Reference needs to be tried before that
  // for Real or Integer; similarly, Real needs to be tried before
  // Integer.
  PDFObj p {o: basic_obj} :=
    d=Dict
    { p.o := basic_obj::Dict(d.d) }
  ;
    a=Array
    { p.o := basic_obj::Array(a.a) }
  ;
    r=Reference
    { p.o := basic_obj::Reference((r.id, r.gen)) }
  ;
    b=Boolean
    { p.o := basic_obj::Boolean(b.b) }
  ;
    r=Real
    { p.o := basic_obj::Real(r.r) }
  ;
    i=Integer
    { p.o := basic_obj::Integer(i.i) }
  ;
    s=String
    { p.o := basic_obj::String(s.s) }
  ;
    n=Name
    { p.o := basic_obj::Name(n.nm) }
  ;
    n=Null
    { p.o := basic_obj::Null() }

  ;;

  // Indirect object parsers get an inherited attribute of the current
  // context, which contains the indirect objects parsed so far.  This
  // is used to forbid duplicates.
  #[whitespace(Whitespace:allow_empty=true)]
  Indirect i (ctxt: parse_ctxt)
             {indirect_obj} :=
    n=Integer [ n.i >  0 ]
    g=Integer [ g.i >= 0 ]
    [ !Map.mem(ctxt, (n.i, g.i)) ] // Forbid duplicate definition.

    !"obj"!
    // Parse the basic object.  Note the special rule for parsing
    // Streams, since they can only be indirect objects.
    ( ( s=Stream { i.obj := basic_obj::Stream((s.dict, s.stream)) } )
    | ( o=PDFObj { i.obj := o.o } )
    )
    !"endobj"!

    // Set the identifiers, and register the object in the context.
    { i.oid  := n.i;
      i.ogen := g.i;
      ctxt   := Map.add(ctxt, (n.i, g.i), i.obj) }

}
