// The basic object primitives.
//
// These are 'basic' in the sense that they do not contain nested
// objects.
//
// The Parsley definitions essentially use regular expression syntax,
// except for LitString, which implements a simple CFG.

fun normalize_name (s : string) -> string = {
  // TODO
  s
}

format {

  // We use syntax like [:hex:], [:alpha:], [:alphanumeric:], [:char:]
  // etc. for standard character classes.
  // We use syntax like ([:char:] \ "(") for set difference.

  Comment := !"%"! (# [Char \ "\n" ]* #) !"\n"!;;

  // The inherited attribute controls whether empty whitespace is
  // allowed.  There is no synthesized attribute.
  Whitespace w (allow_empty : bool) :=
    [allow_empty]
    (# ( [" " | "\0" | "\t" | "\r" | "\n" | "\x0c"] | Comment )* #)
  ; [!allow_empty]
    (# ( [" " | "\0" | "\t" | "\r" | "\n" | "\x0c"] | Comment )* #)
  ;;

  // The synthesized attribute contains the string-valued name without
  // the leading '/'.
  Name n {val : string} :=
    !"/"! s=Alphanum+
    { n.val := normalize_name(s) }
  ;;

  Boolean b {val : bool} :=
    !"true"!  { b.val := true }
  ;
    !"false"! { b.val := false }
  ;;

  Null := !"null"!;;

  RawStream rs (len : int) {bytes : [byte]} :=
    (# ["stream"] ["\n" | "\r\n"] #)
    b=(Byte ^ len)
    (# ["\r" | "\n" | "\r\n"]
       ["endstream"] #)
    { rs.bytes := b } ;;

  HexString hs {val : [byte]} :=
    !"<"!
    ( h1=HexChar h2=HexChar
      { hs.val := (int_of_hex(h1)*16 + int_of_hex(h2)) :: hs.val }
    )*

    ( h=HexChar
      { hs.val := int_of_hex(h1) * 16 :: hs.val}
    )?
    !">"!
    { hs.val := List.rev(hs.val) }
    ;;

  // The below syntax essentially implements a simple CFG for strings with
  // balanced parentheses, using recursion.
  LitString ls { val : [byte] } :=
      !"("!
        prefix=(# [Char \ "("]* #)
        n=LitString
        suffix=(# [Char \ "("]* #)
      !")"!
       { ls.val := ")" + prefix + n.val + suffix + ")" } ;

      (# ["("] #)
        prefix=(# [Char \ "("]* #)
        p=LitString
        midfix=(# [Char \ "("]* #)
        q=LitString
        suffix=(# [Char \ "("]* #)
      !")"!
      { ls.val := "(" + prefix + p.val + midfix + q.val + ")" } ;

      $epsilon                   // Parsley keyword

    ;;

  // A PDF String is one of the above two string objects.
  String s {val : [byte]} :=
    h=HexString { s.val := h.val }
  ;
    l=LitString { s.val := l.val }
  ;;

  // $int_of_string() is a function in the Parsley standard library.
  Integer i { val : int } :=
    n=(# Digit+ #)             { i.val := int_of_string(n)  }
  ;
    !"-"! n=(# Digit+ #) { i.val := -int_of_string(n) }
  ;;

  // TODO: we might need to have a user-defined type for PDF reals,
  // since they are not defined in terms of IEEE 754.
  Real r { val : double } :=
    n=(# Digit+ #)
    { val := $double_of_string(n)  }
  ;
    !"-"! n=(# Digit+ #)
    { val := -double_of_string(n) }
  ;
    n=(# Digit+ #) !"."! f=(# Digit+ #)
    { val :=  double_of_string(n + "." + f) }
  ;
    !"-"!  n=(# Digit+ #) !"."! f=(# Digit+ #)
    { val := -double_of_string(n + "." + f) }

}
