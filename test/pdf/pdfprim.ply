// The basic object primitives.
//
// These are 'basic' in the sense that they do not contain nested
// objects.
//
// The Parsley definitions essentially use regular expression syntax,
// except for LitString, which implements a simple CFG.

fun normalize_name (s : string) -> string = {
  // TODO
  s
}

format PDFPrimitives {

  // We use syntax like [:hex:], [:alpha:], [:alphanumeric:], [:char:]
  // etc. for standard character classes.
  // We use syntax like ([:char:] \ "(") for set difference.

  Comment := "%" a=([:char:] \ "\n")* "\n";;

  // The inherited attribute controls whether empty whitespace is
  // allowed.  There is no synthesized attribute.
  Whitespace w (allow_empty : bool) :=
    [allow_empty]
    (" " | "\0" | "\t" | "\r" | "\n"
     | "\x0c" // form-feed
     | Comment
    )*
  ; [!allow_empty]
    (" " | "\0" | "\t" | "\r" | "\n"
     | "\x0c" // form-feed
     | Comment
    )+
  ;;

  // The synthesized attribute contains the string-valued name without
  // the leading '/'.
  Name n {val : string} :=
    "/" s=([:alphanum:]+)
    { n.val := normalize_name(s) }
  ;;

  Boolean b {val : bool} :=
    "true"  { b.val := true }
  ;
    "false" { b.val := false }
  ;;

  Null := "null" ;;

  RawStream rs (len : int) {bytes : [byte]} :=
    "stream"            ("\n" | "\r\n")
    b=([[:byte:] * len])  ("\r" | "\n" | "\r\n")
    "endstream"
    { rs.bytes := b } ;;

  HexString hs {val : [byte]} :=
    "<"
    ( h1=([:hex:]) h2=([:hex:])
      { hs.val := ($int_of_hex(h1)*16 + $int_of_hex(h2)) :: hs.val }
    )*

    ( h=([:hex:])
      { hs.val := $int_of_hex(h1) * 16 :: hs.val}
    )?
    ">"
    { hs.val := List.rev(hs.val) }
    ;;

  // The below syntax essentially implements a simple CFG for strings with
  // balanced parentheses, using recursion.
  LitString ls { val : [byte] } :=
      "("
        prefix=([:char:] \ "(")*
        n=LitString
        suffix=([:char:] \ "(")*
      ")"
       { ls.val := ")" + prefix + n.val + suffix + ")" } ;

      "("
        prefix=([:char:] \ "(")*
        p=LitString
        midfix=([:char:] \ "(")*
        q=LitString
        suffix=([:char:] \ "(")*
      ")"
      { ls.val := "(" + prefix + p.val + midfix + q.val + ")" } ;

      $epsilon                   // Parsley keyword

    ;;

  // A PDF String is one of the above two string objects.
  String s {val : [byte]} :=
    h=HexString { s.val := h.val }
  ;
    l=LitString { s.val := l.val }
  ;;

  // $int_of_string() is a function in the Parsley standard library.
  Integer i { val : int } :=
    n=([:digit:])+   { i.val := $int_of_string(n)  }
  ;
    "-" n=([:digit:])+ { i.val := -$int_of_string(n) }
  ;;

  // TODO: we might need to have a user-defined type for PDF reals,
  // since they are not defined in terms of IEEE 754.
  Real r { val : double } :=
    n=([:digit:])+
    { val := $double_of_string(n)  }
  ;
    "-"  n=([:digit:])+
    { val := -$double_of_string(n) }
  ;
    n=([:digit:])+ "." f=([:digit:])+
    { val :=  $double_of_string(n + "." + f) }
  ;
    "-"  n=([:digit:])+ "." f=([:digit:])+
    { val := -$double_of_string(n + "." + f) }

}
