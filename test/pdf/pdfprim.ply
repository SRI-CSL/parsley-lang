// The basic object primitives.
//
// These are 'basic' in the sense that they do not contain nested
// objects.
//
// The Parsley definitions essentially use regular expression syntax,
// except for LitString, which implements a simple CFG.

fun normalize_name (s : string) -> string = {
  // TODO
  s
}

format {

  // Parsers are provided in the standard library for primitives
  // such as Char for ASCII characters, U8 for unsigned bytes, etc.

  // We use syntax like (Char \ "(") for set difference.  To specify
  // literals directly in a production, we quote them within a matched
  // !! pair.  Regular expression constructions need to be enclosed
  // within (# #), and when bound to an identifier have a byte-vector
  // value.

  // The 'Comment' non-terminal will have a byte vector type.
  Comment := !"%"! (# [Char \ "\n" ]* #) !"\n"!;;

  // The 'Whitespace' non-terminal has a boolean inherited attribute
  // 'allow_empty', which is used within constraint expressions that
  // are enclosed in [].  It has a byte-vector value.
  Whitespace w (allow_empty : bool) :=
    [allow_empty]
    (# ( [" " | "\0" | "\t" | "\r" | "\n" | "\x0c"] | Comment )* #)
  ; [!allow_empty]
    (# ( [" " | "\0" | "\t" | "\r" | "\n" | "\x0c"] | Comment )* #)
  ;;

  // The 'Name' non-terminal has a synthesized attribute 'val' that
  // contains the string-valued name without the leading '/'.
  Name n {val : string} :=
    !"/"! s=Alphanum+
    { n.val := normalize_name(s) }
  ;;

  Boolean b {val : bool} :=
    !"true"!  { b.val := true }
  ;
    !"false"! { b.val := false }
  ;;

  Null := !"null"!;;

  // Bounded repetition (e.g. N times) of a non-terminal 'NT' can be
  // specified by (NT ^ N), where N has to have an integer value.
  // RawStream is given an inherited attribute 'len' that controls how
  // long the payload is.
  RawStream rs (len : int) {bytes : [byte]} :=
    (# ["stream"] ["\n" | "\r\n"] #)
    b=(Byte ^ len)
    (# ["\r" | "\n" | "\r\n"]
       ["endstream"] #)
    { rs.bytes := b } ;;

  HexString hs {val : [byte]} :=
    !"<"!
    ( h1=HexChar h2=HexChar
      { hs.val := (int_of_hex(h1)*16 + int_of_hex(h2)) :: hs.val }
    )*

    ( h=HexChar
      { hs.val := int_of_hex(h1) * 16 :: hs.val}
    )?
    !">"!
    { hs.val := List.rev(hs.val) }
    ;;

  // The below syntax essentially implements a simple CFG for strings with
  // balanced parentheses, using recursion.
  LitString ls { val : [byte] } :=
      !"("!
        prefix=(# [Char \ "("]* #)
        n=LitString
        suffix=(# [Char \ "("]* #)
      !")"!
       { ls.val := ")" + prefix + n.val + suffix + ")" } ;

      (# ["("] #)
        prefix=(# [Char \ "("]* #)
        p=LitString
        midfix=(# [Char \ "("]* #)
        q=LitString
        suffix=(# [Char \ "("]* #)
      !")"!
      { ls.val := "(" + prefix + p.val + midfix + q.val + ")" } ;

      $epsilon                   // Parsley keyword

    ;;

  // A PDF String is one of the above two string objects.
  String s {val : [byte]} :=
    h=HexString { s.val := h.val }
  ;
    l=LitString { s.val := l.val }
  ;;

  // int_of_string() is a function in the Parsley standard library.
  Integer i { val : int } :=
    n=(# Digit+ #)             { i.val := int_of_string(n)  }
  ;
    !"-"! n=(# Digit+ #) { i.val := -int_of_string(n) }
  ;;

  // TODO: we might need to have a user-defined type for PDF reals,
  // since they are not defined in terms of IEEE 754.
  Real r { val : double } :=
    n=(# Digit+ #)
    { val := double_of_string(n)  }
  ;
    !"-"! n=(# Digit+ #)
    { val := -double_of_string(n) }
  ;
    n=(# Digit+ #) !"."! f=(# Digit+ #)
    { val :=  double_of_string(n + "." + f) }
  ;
    !"-"!  n=(# Digit+ #) !"."! f=(# Digit+ #)
    { val := -double_of_string(n + "." + f) }

}
