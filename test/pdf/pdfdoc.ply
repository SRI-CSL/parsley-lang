// Top-level document syntax.

use pdfprim:{
  Name, NameT, Integer, IntegerT, Comment, CommentT
}
use pdfobj:{
  obj_ctxt, ObjType, Indirect, IndirectT, PDFObj, Dict
}

type xref_status =
    Free of { next : int }
  | InUse of { file_ofs : int }

type xref_ent =
  { obj : int,
    gen : int,
    status : xref_status }

format PDFDoc
{
  Header h { version : commentT,
             binary  : option<commentT> }
  :=
    v=Comment  b=Comment?
    { version := v;
      binary  := b
    }
  ;;

  Body b (ctxt : obj_ctxt) { body: [indirectT] } :=
    ( i=Indirect<ctxt = b.ctxt>
      { b.body := b.body.append(i) }
    )*
  ;;

  XrefSect x { sects: [xrefSubSectT] } :=
    "xref"
    ( s=XrefSubSect
      { x.sects := x.sects.append(s) }
    )*
  ;;

  XrefSubSect x { start: int,
                  count: int,
		  ents: [xrefEntT] }
  :=
    (| i : int |)  // entry loop counter

    // TODO: handle disabling implicit whitespace here
    s=Integer [ s.val >= 0 ]
    c=Integer [ s.val >  0 ]
    "\n"   // TODO: specify EOL-type
    { x.start := s.val;
      x.count := c.val }

    ( e=XrefEnt<idx = i>
      [ x.ents.len() < x.count ]
      { x.ents := x.ents.append(e);
        i := i + 1 }
    )*

    // Ensure we got the specified number of entries.
    [ x.ents.len() = x.count ]
  ;;

  XrefEnt x (idx : int) { xref_ent }
  :=
    o=([[:digit:] * 10]) g=([[:digit:] * 5])
    { x.obj := x.idx;
      x.gen := $string_to_int(g) }
    (( "n"
       { x.status :=
           let file_ofs = $string_to_int(o) in
           xref_status::InUse({ file_ofs: file_ofs }) }
     )
    |
     ( "f"
       { x.status :=
         let next = $string_to_int(o) in
	 xref_status::Free({ next: next }) }
     )
    )
    "\r\n"
  ;;

  Trailer t (ctxt : obj_ctxt) { dict: dictT } :=
    "trailer" d=Dict<ctxt = t.ctxt>
    { t.dict := d }
  ;;

  StartXref s { val : int } :=
    "startxref"
    n=Integer
    [ n.val > 0 ]
    { s.val := n.val }
  ;;

  EOF {} :=
    "%%EOF"
}
