// Top-level document syntax.

use {pdfprim, pdfobj}

type xr_free     = { xr_next: int }
type xr_inuse    = { xr_file_ofs: int }
type xr_instream = { xr_stream_obj: int, xr_obj_index: int }

type xr_status =
  | Free of xr_free
  | InUse of xr_inuse
  | InStream of xr_instream

type xref_ent =
  { xr_obj: int,
    xr_gen: int,
    xr_status: xr_status }

type xref_ssect =
  { xss_start: int, xss_count: int, xss_ents: [xref_ent] }

type xref_sect =
  { xs_sects: [xref_ssect] }

format {
  Header h { version : [byte],
             binary  : option<[byte]> }
  :=
    v=Comment  b=Comment?
    { h.version := v;
      h.binary  := b }
  ;;

  // Straight-line parser that does not use xref table.
  #[whitespace(Whitespace:allow_empty=true)]
  Body b (ctxt : parse_ctxt) { body: [indirect_obj] } :=
    ( i=Indirect<ctxt = ctxt>
      { b.body := i :: b.body }
    )*
  ;;

  // XRef entries in Xref table
  XrefEnt e (idx: int) { xref_ent } :=
    n=(# DigitS ^ 10 #) !" "!
    g=(# DigitS ^ 5 #) !" "!
    [ Int.of_bytes_unsafe(g) <= 65535 ]

    (( !"n"!
       { let iu = { xr_file_ofs: Int.of_bytes_unsafe(n) } in
         e.xr_status := xr_status::InUse(iu) } )
     |
     ( !"f"!
       { let f = { xr_next: Int.of_bytes_unsafe(n) } in
         e.xr_status := xr_status::Free(f) }
     ))

    ( !" \r"! | !" \n"! | !"\r\n"! )
    { e.xr_obj := idx;
      e.xr_gen := Int.of_bytes_unsafe(g) }
  ;;

  XrefSubSect ss { xref_ssect } :=
  (| i : int := 0 |)                    // temporary used as counter

  start=(# DigitS+ #) !" "!
  { i := Int.of_bytes_unsafe(start) }   // initialize the object counter

  count=(# DigitS+ #)

  ( !" \r"! | !" \n"! | !"\r\n"! )      // unclear in the spec

  (xe=XrefEnt<idx = i>
   { ss.xss_ents := xe :: ss.xss_ents;
     i := i + 1 }                       // increment counter for next object
  ) ^ (Int.of_bytes_unsafe(count))

  { ss.xss_ents := List.rev(ss.xss_ents) }
  ;;

  #[whitespace(Whitespace:allow_empty=true)]
  XrefSect xs { xref_sect } :=
  !"xref"!  PDF_EOL
  (ss=XrefSubSect { xs.xs_sects := ss :: xs.xs_sects }) *
  { xs.xs_sects := List.rev(xs.xs_sects) }
  ;;

  #[whitespace(Whitespace:allow_empty=true)]
  Trailer t {tdict: dict} :=
    !"trailer"! d=Dict
    { t.tdict := d.d }
  ;;

  #[whitespace(Whitespace:allow_empty=false)]
  StartXref s {sxref : int} :=
    !"startxref"!
    n=Integer
    [ n.i > 0 ]
    { s.sxref := n.i }
  ;;

  EOF {} :=
    !"%%EOF"!
}
