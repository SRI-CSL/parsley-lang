fun more_than_five(b : [byte]) -> bool = {
  (case Int.of_bytes(b) of
   | option::Some(i) -> i > 5
   | option::None()  -> bool::False())
}

format {

  // Match a byte.
  A := (# ["A"] #);;

  // Match a range of bytes.
  R := (# ["0" .. "9"] #);;

  // Binary integers using builtins.  Bytes don't need endianness.
  I8    := Int8;;
  U64LE := UInt64<endian=endian::Little()>;;

  // Match a set of bytes: need to enumerate the set.
  Set := (# [ "0" | "5" | "9" ] #);;

  // Pure parser
  Pure p { val: [byte] } := { p.val := "A" };;
  // with optional initializer
  Pure2 p { val2: [byte] := [] } := { p.val2 := "A" };;

  // Sequencing and Selection
  ABC1 p {a: [byte]} := !"Helo"! v=!"ABC"! {p.a := v};;
  ABC2 p {b: [byte]} := a=!"Helo"! b=!"ABC"! {p.b := List.concat(a, b)};;

  // Select p {p: typ} := P q=Q R {p.p := q};;

  // Local variables
  Add a {sum: int} := x=Byte !"+"! y=Byte
    {a.sum := Int.of_byte(x) + Int.of_byte(y)};;

  // Structuring
  Struct s {x: int, y: [byte]} := x=Byte y=!"Hello"!
    {s.x := Int.of_byte(x); s.y := y};;

  // Constraints
  C p {c: [byte]} :=
      i=(# [ "0" .. "9" ] #)
      (([more_than_five(i)] { p.c := "gt 5" })
        | { p.c := "leq 5 or not int" }
      );;

  // Scanning for a tag: forwards
  SF s {sf: [byte]} :=
     bs=/sf["tag"] { s.sf := bs };;

  // Scanning for a tag: backwards
  SB s {sb: [byte]} :=
     bs=/sb["tag"] { s.sb := bs };;

  // Example of a common dependent type:
  // 'c' captures a byte that represents the length of a vector of
  // bytes, captured by 'v'.  The conversion of 'c' into the integer length
  // value is done by the library function Int.of_byte().
  DepVec dv { vec: [byte] } :=
    c=Byte v=(Byte ^ Int.of_byte(c))
    { dv.vec := v }
}

// This data-dependent vector count also applies for non-terminals.
type recd = { t : byte }
fun byte_of_recd (r : recd) -> byte = { r.t }

format {

  NonTerm nt { recd } :=
    c=Byte
    { nt.t := c } ;;

  DepNTVec dv { depvec: [byte] } :=
    c=Byte v=(NonTerm ^ Int.of_byte(c))
    { dv.depvec := List.map(byte_of_recd, v) } ;;

  // The dependent count can be an attribute of a previously parsed
  // non-terminal.

  NTDepNTVec dv { depntvec: [byte] } :=
    c=NonTerm v=(NonTerm ^ Int.of_byte(c.t))
    { dv.depntvec := List.map(byte_of_recd, v) }

}
