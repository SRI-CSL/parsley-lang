fun more_than_five(b : [byte]) -> bool = {
  (case int_of_bytes(b) of
   | option::Some(i) -> i > 5
   | option::None()  -> bool::False())
}

format {

  // Match a byte.
  A := (# ["A"] #);;

  // Match a range of bytes.
  R := (# ["0" .. "9"] #);;

  // Match a set of bytes: need to enumerate the set.
  Set := (# [ "0" | "5" | "9" ] #);;

  // Pure parser
  Pure p { val: [byte] } := { p.val := "A" };;

  // Sequencing and Selection
  ABC1 p {a: [byte]} := !"Helo"! v=!"ABC"! {p.a := v};;
  ABC2 p {b: [byte]} := a=!"Helo"! b=!"ABC"! {p.b := List.concat(a, b)};;

  // Select p {p: typ} := P q=Q R {p.p := q};;

  // Local variables
  Add a {sum: int} := x=Byte !"+"! y=Byte
    {a.sum := int_of_byte(x) + int_of_byte(y)};;

  // Structuring
  Struct s {x: int, y: [byte]} := x=Byte y=!"Hello"!
    {s.x := int_of_byte(x); s.y := y};;

  // Constraints
  C p {c:[byte]} :=
      i=(# [ "0" .. "9" ] #)
      (([more_than_five(i)] { p.c := "gt 5" })
        | { p.c := "leq 5 or not int" }
      );;

  // Example of a common dependent type:
  // 'c' captures a byte that represents the length of a vector of
  // bytes, captured by 'v'.  The conversion of 'c' into the integer length
  // value is done by the library function int_of_byte().
  DepVec dv { vec: [byte] } :=
    c=Byte v=(Byte ^ int_of_byte(c))
    { dv.vec := v }
}

// This data-dependent vector count also applies for non-terminals.
type recd = { t : byte }
fun byte_of_recd (r : recd) -> byte = { r.t }

format {

  NonTerm nt { recd } :=
    c=Byte
    { nt.t := c } ;;

  DepNTVec dv { depvec: [byte] } :=
    c=Byte v=(NonTerm ^ int_of_byte(c))
    { dv.depvec := List.map(byte_of_recd, v) } ;;

  // The dependent count can be an attribute of a previously parsed
  // non-terminal.

  NTDepNTVec dv { depntvec: [byte] } :=
    c=NonTerm v=(NonTerm ^ int_of_byte(c.t))
    { dv.depntvec := List.map(byte_of_recd, v) }

}
