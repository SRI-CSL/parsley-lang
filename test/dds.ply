// This Parsley file is based on the RTPS specification: https://www.omg.org/spec/DDSI-RTPS/2.3/Beta1/PDF
// We implement Section 9.4.

// We make no assumption about the IP or TCP layer packets and only
// operate on the application layer data.

// Call with `./parsleyc.exe -df dds.dat -ex DDS test/dds.ply`
// where dds.dat is a file containing the RTPS payload

// TODO: If there are dangling bytes at the end that are not matched to any nonterminal,
// we do not throw an error. This needs to be looked into. Parsley possibly needs an
// improvement with an additional feature.

type submessage = {messagetype: string, data: [byte], nextoctet: int}
type locator = {kind: int, port: int, address: [byte]}

// We use this bitfield type to extract flags from the InfoTS type
bitfield bitf_infots = {
  ignore: 7:2,
  i: 1,
  e: 0
}

// We use this bitfield type to extract flags from the InfoReply type
bitfield bitf_inforeply = {
  ig: 7:2,
  m: 1,
  e1: 0
}

// We use this bitfield type to extract flags from the Pads type
bitfield bitf_pads = {
  ign: 7:1,
  e2: 0
}

format {
  DDS d {magic: [byte], imajor: int, iminor: int, submessages: [submessage]} := magic=!"RTPS"!
                                                                                version=ProtocolVersion
                                                                                vendor=VendorId
                                                                                prefix=(Byte ^ 12)
                                                                                submessages=(SubMessage)*
                                                                                checkbytes=(Byte)*
  [List.length(submessages) > 0 && List.length(checkbytes) = 0]
  {d.magic := magic; d.imajor := version.major ; d.iminor := version.minor; d.submessages := submessages}
  // Ensure we have at least one submessage
  ;;

  // Submessage IDs we use conform to Section 9.4.5.1.1
  SubMessage sub {submessage} := a=HeartBeat {sub.messagetype := String.of_bytes_unsafe("HeartBeat"); sub.data:= []; sub.nextoctet := 0} ;
                                      a = DataFrag {sub.messagetype := String.of_bytes_unsafe("DataFrag"); sub.data:= a.fragserializeddata; sub.nextoctet := 0} ;
                                      a = InfoDest {sub.messagetype := String.of_bytes_unsafe("InfoDest"); sub.data:= []; sub.nextoctet := 0} ;
                                      a=AckNack {sub.messagetype := String.of_bytes_unsafe("AckNack"); sub.data:= []; sub.nextoctet := 0} ;
                                      a=Data {sub.messagetype := String.of_bytes_unsafe("Data"); sub.data:= a.serializeddata; sub.nextoctet := 0} ;
                                      a=Gap {sub.messagetype := String.of_bytes_unsafe("Gap"); sub.data:= []; sub.nextoctet := 0} ;
                                      a=InfoTS {sub.messagetype := String.of_bytes_unsafe("InfoTS"); sub.data:= a.timestamp; sub.nextoctet := a.octets_ts} ;
                                      a=InfoSrc {sub.messagetype := String.of_bytes_unsafe("InfoSrc"); sub.data:= []; sub.nextoctet := 0} ;
                                      a=HeartBeatFrag {sub.messagetype := String.of_bytes_unsafe("HeartBeatFrag"); sub.data:= []; sub.nextoctet := 0} ;
                                      a=NackFrag {sub.messagetype := String.of_bytes_unsafe("AckNackFrag"); sub.data:= []; sub.nextoctet := 0} ;
                                      a=Pad {sub.messagetype := String.of_bytes_unsafe("Pad"); sub.data:= []; sub.nextoctet := 0} ;
                                      a=InfoReply {sub.messagetype := String.of_bytes_unsafe("InfoReply"); sub.data:= []; sub.nextoctet := 0}
                                      // Only data from Data, DataFrag, and InfoTS are useful and stored.
                                      ;;

  ProtocolVersion v {major: int, minor: int} := major=UInt8 minor=UInt8
                                                {v.major := major ; v.minor := minor}
  ;;

  VendorId v {vendorid: [byte]} := b=(Byte ^ 2)
                                  {v.vendorid := b}
  ;;

  // Section 9.4.2.10
  // Locator and LocatorList mainly used in InfoReply type
  Locator l (endian: bool) {locator} := ([endian = bool::True()] kind=UInt32<endian=endian::Little()>
                                                        port=UInt32<endian=endian::Little()>
                                                        octet=(Byte ^ 16)
                                                        {
                                                          l.kind := kind;
                                                          l.port := port;
                                                          l.address := octet
                                                        }
                                        ) |
                                        ([endian = bool::False()] kind=UInt32<endian=endian::Big()>
                                                        port=UInt32<endian=endian::Big()>
                                                        octet=(Byte ^ 16)
                                                        {
                                                          l.kind := kind;
                                                          l.port := port;
                                                          l.address := octet
                                                        }
                                        )
  ;;

  LocatorList l (endian: bool) {numlocators: int, locators: [locator]} := ([endian = bool::True()] nums=UInt32<endian=endian::Little()>
                                                            locators=(Locator<endian = endian> ^ nums)
                                                            {
                                                              l.numlocators := nums;
                                                              l.locators := locators
                                                            }) |
                                                            ([endian = bool::False()] nums=UInt32<endian=endian::Big()>
                                                            locators=(Locator<endian = endian> ^ nums)
                                                            {
                                                              l.numlocators := nums;
                                                              l.locators := locators
                                                            })
  ;;

  // SequenceNumberSet type
  SequenceNumberSet s (endian: bool) {n: int, bitmaps: [int]} :=
            bitmapbase=SequenceNumber<endian = endian>
  ([endian = bool::True()]
      numbits = UInt32<endian=endian::Little()>
      {s.n := (numbits + 31)/32}
      bitmaps=(UInt32<endian=endian::Little()> ^ s.n)
      {s.bitmaps := bitmaps}
  ) |
  ([endian = bool::False()]
      numbits = UInt32<endian=endian::Big()>
      {s.n := (numbits + 31)/32}
      bitmaps=(UInt32<endian=endian::Big()> ^ s.n)
      {s.bitmaps := bitmaps}
  )
  ;;

  SequenceNumber s (endian: bool) {bitmapbase: int} := ([endian = bool::True()]
      bitmapbase = UInt64<endian=endian::Little()>
      {s.bitmapbase := bitmapbase}
     ) |
  ([endian = bool::False()]
      bitmapbase = UInt64<endian=endian::Big()>
      {s.bitmapbase := bitmapbase}
  )
  ;;

  OctetsToNextHeader o (endian: bool) {octets: int} := ([endian = bool::True()]
      bitmapbase = UInt16<endian=endian::Little()>
      {o.octets := bitmapbase}
     ) |
  ([endian = bool::False()]
      bitmapbase = UInt16<endian=endian::Big()>
      {o.octets := bitmapbase}
  )
  ;;

  // Section 9.4.5.2
  AckNack d {acknackcount: int} := magic=!"\x06"!
                                    flags=$bitfield(bitf_pads)
                                    (([Bits.to_bool(Bits.to_bit(flags.e2)) = bool::True()]
                                    octetsToNextHeader=UInt16<endian=endian::Little()>
                                    readerEntityID=UInt32<endian=endian::Little()>
                                    writerEntityID=UInt32<endian=endian::Little()>
                                    readerSNState=SequenceNumberSet<endian = bool::True()>
                                    count=UInt32<endian=endian::Little()>
                                    {d.acknackcount := count}) |
                                    ([Bits.to_bool(Bits.to_bit(flags.e2)) = bool::True()]
                                    octetsToNextHeader=UInt16<endian=endian::Little()>
                                    readerEntityID=UInt32<endian=endian::Little()>
                                    writerEntityID=UInt32<endian=endian::Little()>
                                    readerSNState=SequenceNumberSet<endian = bool::False()>
                                    count=UInt32<endian=endian::Little()>
                                    {d.acknackcount := count}))
  ;;

  // Section 9.4.5.3
  Data d {serializeddata: [byte]} := magic=!"\x15"!
                                      flags = Byte
                                      octetsToNextHeader=UInt16<endian=endian::Little()>
                                      extraflags=(Byte^2)
                                      readerEntityID=UInt32<endian=endian::Little()>
                                      writerEntityID=UInt32<endian=endian::Little()>
                                      writerSeqNumber=UInt64<endian=endian::Little()>
                                      serializedData=(Byte)*
                                      {d.serializeddata := serializedData}
  ;;

  // Section 9.4.5.4
  DataFrag d {fragserializeddata: [byte], samplesize: int} := magic=!"\x16"!
                                                              flags=Byte
                                                              octetsToNextHeader=UInt16<endian=endian::Little()>
                                                              extraflags=(Byte^2)
                                                              readerEntityID=UInt16<endian=endian::Little()>
                                                              writerEntityID=UInt32<endian=endian::Little()>
                                                              writerSeqNumber=SequenceNumber<endian = bool::False()>
                                                              fragmentStartingNum=UInt32<endian=endian::Little()>
                                                              fragmentsInSubmessage=UInt16<endian=endian::Little()>
                                                              fragmentSize=UInt16<endian=endian::Little()>
                                                              sampleSize=UInt32<endian=endian::Little()>
                                                              serializedData=(Byte)*
                                                              {d.fragserializeddata := serializedData; d.samplesize := sampleSize}
  ;;

  // Section 9.4.5.5
  Gap d {bitmap_list: [int], numBits: int} := magic=!"\x08"!
                                            flags=Byte
                                            octetsToNextHeader=UInt16<endian=endian::Little()>
                                            readerEntityID=UInt32<endian=endian::Little()>
                                            writerEntityID=UInt32<endian=endian::Little()>
                                            gapStart=SequenceNumber<endian = bool::True()>
                                            gapList=SequenceNumberSet<endian = bool::True()>
                                            {d.bitmap_list := gapList.bitmaps; d.numBits := gapList.n}
  ;;

  // Section 9.4.5.6
  HeartBeat b {count: int} := magic=!"\x07"!
                              flags=Byte
                              octetsToNextHeader=UInt16<endian=endian::Little()>
                              readerEntityId=UInt32<endian=endian::Little()>
                              writerEntityId=UInt32<endian=endian::Little()>
                              firstAvailableSeqNumber=SequenceNumber<endian = bool::True()>
                              lastSeqNumber=SequenceNumber<endian = bool::True()>
                              count=UInt32<endian=endian::Little()>
                              {b.count := count}
  ;;

  // Section 9.4.5.7
  HeartBeatFrag b {frag_count: int} := magic=!"\x07"!
                                        flags=Byte octetsToNextHeader=UInt16<endian=endian::Little()>
                                        readerEntityId=UInt32<endian=endian::Little()>
                                        writerEntityId=UInt32<endian=endian::Little()>
                                        writerSN=SequenceNumber<endian = bool::True()>
                                        lastFragmentNumber=UInt32<endian=endian::Little()>
                                        count=UInt32<endian=endian::Little()>
                                        {b.frag_count := count}
  ;;

  // Section 9.4.5.8
  InfoDest d {infodestguidprefix: [byte]} := magic=!"\x0e"!
                                              flags=Byte
                                              octetsToNextHeader=UInt16<endian=endian::Little()>
                                              guidprefix=(Byte ^ 12)
                                              {d.infodestguidprefix := guidprefix}
  ;;


  SNBits sn {size: int} := numbits=UInt32<endian=endian::Little()>
                           {sn.size := (numbits+31)/32}
  ;;

  // // Section 9.4.5.9
  InfoReply if {flags1: bitf_inforeply} := magic=!"\x0d"!
                      flags=$bitfield(bitf_inforeply)
                      octets=OctetsToNextHeader<endian = Bits.to_bool(Bits.to_bit(flags.e1))>
                      ((unicast=LocatorList<endian = Bits.to_bool(Bits.to_bit(flags.e1))>) |
                      (unicast=LocatorList<endian = Bits.to_bool(Bits.to_bit(flags.e1))>
                        multicast=LocatorList<endian = Bits.to_bool(Bits.to_bit(flags.e1))>
                        [Bits.to_bool(Bits.to_bit(flags.m)) = bool::True()]))
                      // if M is 1, then locatorlist present
                      {if.flags1 := flags}
  ;;

  // Section 9.4.5.10
  InfoSrc d {infosrcguidprefix: [byte]} := magic=!"\x0c"!
                                           flags=Byte
                                           octetsToNextHeader=UInt16<endian=endian::Little()>
                                           unused=(Byte^4)
                                           version=ProtocolVersion
                                           vendor=VendorId
                                           guidprefix=(Byte ^ 12)
                                           {d.infosrcguidprefix := guidprefix}
  ;;

  // Section 9.4.5.13
  NackFrag d {nackfragcount: int} := magic=!"\x12"!
                                            flags=Byte
                                            octetsToNextHeader=UInt16<endian=endian::Little()>
                                            readerEntityID=UInt32<endian=endian::Little()>
                                            writerEntityID=UInt32<endian=endian::Little()>
                                            writerSN=SequenceNumber<endian = bool::True()>
                                            fragmentNumberState=SequenceNumberSet<endian = bool::True()>
                                            count=UInt32<endian=endian::Little()>
                                            {d.nackfragcount := count}
  ;;

  // Section 9.4.5.12
  // Flag e = 1 means little endian, e=0 means bit endian
  Pad d {octet: int} := magic=!"\x01"!
                                           flags=$bitfield(bitf_pads)
                                           (([Bits.to_bool(Bits.to_bit(flags.e2)) = bool::True()]
                                           octetsToNextHeader=UInt16<endian=endian::Little()>
                                           {d.octet := octetsToNextHeader}
                                           skip=(Byte ^ octetsToNextHeader)
                                           ) |
                                           ([Bits.to_bool(Bits.to_bit(flags.e2)) = bool::False()]
                                           octetsToNextHeader=UInt16<endian=endian::Big()>
                                           {d.octet := octetsToNextHeader}
                                           skip=(Byte ^ octetsToNextHeader)
                                           ))
  ;;

  // Section 9.4.5.11
  InfoTS d {timestamp: [byte], f: bitf_infots, octets_ts: int} := magic=!"\x09"! flags=$bitfield(bitf_infots) {d.f := flags}
      // We have two choices based on I
      // If I is false, then we have a timestamp. If I is true then no timestamp: skip to the next byte
      ((
        [Bits.to_bool(Bits.to_bit(flags.i)) = bool::False()]
        octetsToNextHeader=OctetsToNextHeader<endian=Bits.to_bool(Bits.to_bit(flags.e))>
        timestamp=(Byte ^ 8) {d.timestamp := timestamp}
        {d.octets_ts := octetsToNextHeader.octets - 8}
        ) |

        ([Bits.to_bool(Bits.to_bit(flags.i)) = bool::True()]
          octetsToNextHeader=OctetsToNextHeader<endian=Bits.to_bool(Bits.to_bit(flags.e))>
         {d.timestamp := []}
        {d.octets_ts := octetsToNextHeader.octets}
        ))
        skip = (Byte ^ (d.octets_ts))
}