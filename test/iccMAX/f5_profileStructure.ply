// This file corresponds to the general profile structure
// It captures Figure 5 on page 16 of the 2019 iccMAX spec.

// This also serves as the entry point to the parsing

use aux
use t63_multiProcessElementsType

const header_len: int = 128
const four : int = 4

type signature_type = {
  sig_bytes : [byte]
}

type tag_entry_type = {
  tag_signature : [byte],
  data_element_offset : int,
  data_element_size : int
}

type tag_table_type = {
  count : int,
  entries : [tag_entry_type]
}

type profile_structure_type = {
  header : [byte],
  tag_table : tag_table_type
}

recfun create_views_from_tag_entries (v: view, tag_entries: [tag_entry_type]) -> [view] = {
  (case tag_entries of
    | [] ->  []
    | first :: rest ->
        View.restrict(View.get_current(),
                      first.data_element_offset, 
                      first.data_element_size + four_byte_padding_len(first.data_element_offset + first.data_element_size))
        :: create_views_from_tag_entries(v, rest)
  )
}

// check that an individual tag signature corresponds to a tag type signature
// this would be a massive case statement on tag_sig where the body of each case clause 
// contains another case statement that compares ele_sig against permissible signatures 
// associated with tag_sig according to Clause 9.
// this is out of scope for us
fun validate_signature (tag_sig: [byte], ele_sig: [byte]) -> bool = {
  (case tag_sig of 
    | _ -> bool::True())
}

format {

  // this non-terminal corresponds to processing Figure 5
  ParseFile pt {profile_structure_type} :=
    
    v = {;; View.clone(View.get_current())}

    // parse header and tag table
    header = (Byte^header_len)
    tag_table = TagTable
    [tag_table.count >= 0]
    {
      pt.header := header;
      pt.tag_table := tag_table
    }

    // create views for tag data elements and then parse tagged element data
    views = {;; create_views_from_tag_entries(v, pt.tag_table.entries)} 
    @#[views, ProcessTaggedElementData<te <- (pt.tag_table.entries)>]
    ;;

  // process the tagged element data corresponding to a single entry
  // validate signature against tag entry type
  // and then process the tagged element data set
  ProcessTaggedElementData (te: tag_entry_type) {void_type} :=
    ele_sig = (Byte^4)
    [validate_signature(te.tag_signature, ele_sig)]
    @[View.get_base(), ProcessTaggedElementDataHelper<te = te, ele_sig = ele_sig>]
    
    // NEED TO FINISH...CHECK PADDING.
    // padding_len = { ;; four_byte_padding_len(te.data_element_size)}
    //@[View.restrict(View.get_base(), te.data_element_size, padding_len), AlignFourBytes]
    ;;

  // helper for ProcessTaggedElementData
  // process tagged element data after ele_sig has been validated
  // we only validate mpet right now
  ProcessTaggedElementDataHelper (te: tag_entry_type, ele_sig: [byte]) {void_type} :=
    [ele_sig = "mpet"]
    MultiProcessElements<len = te.data_element_size>
    ;
    [ele_sig != "mpet"]
    ;;

  TagTable tt {tag_table_type} :=
    tt_count = UInt32<endian=endian::Big()>
    tt_entries = (TagEntry^tt_count)
    {
      tt.count := tt_count;
      tt.entries := tt_entries
    };;

  TagEntry te {tag_entry_type} :=
    tag_signature = (Byte^four) // something like: \x05\x03
    data_offset = UInt32<endian=endian::Big()>
    data_size = UInt32<endian=endian::Big()>
    {
      te.tag_signature := tag_signature;
      te.data_element_offset := data_offset;
      te.data_element_size := data_size
    }
}
