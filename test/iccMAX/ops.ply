// B.H. Note: copy of https://github.com/SRI-CSL/parsley-lang/blob/master/test/lang/ops.ply from PrashanthM

// this resource signature currently only models the stack
type resource =
{ consume: int,
  produce: int }

type operation =
 | If of resource * [operation]
 | If_else of resource * [operation] * [operation]
 // ... other ops

 // BH note: Table 96, Stack operations by signature, pg. 104
 | Copy of resource
 | Rotl of resource
 | Rotr of resource
 | Posd of resource
 | Flip of resource
 | Pop of resource

recfun num_ops (o: operation) -> int = {
  (case o of
   | operation::If(_, s) ->
       1 + num_stream_ops(s, 0)
   | operation::If_else(_, s, t) ->
       2 + num_stream_ops(s, 0) + num_stream_ops(t, 0)

   // other ops
   // BH note: advised by PrashanthM to make this part a wildcard
   | _ -> 1
  )
}

and num_stream_ops (os: [operation], acc: int) -> int = {
  (case os of
   | [] -> acc
   | hd :: tl -> num_ops(hd) + num_stream_ops(tl, acc)
  )
}

format {
  // BH. accounting for UInt16
  U16 := UInt16<endian=endian::Big()> ;;

  U32 := UInt32<endian=endian::Big()> ;;

  Operation o {op: operation} :=
      !"if  "! t=U32
      !"else"! u=U32
      tv = {;; let v = View.get_current() in
               View.restrict(v, 0, 8*t) }
      uv = {;; let v = View.get_current() in
               let v = View.restrict_from(v, 8*t) in
               View.restrict(v, 0, 8*u) }
      ifops  = @[tv, OpStream<nops = t>]
      elsops = @[uv, OpStream<nops = u>]
      { let r = { consume: 1,
                  produce: 0 } in
        o.op := operation::If_else(r, ifops, elsops) }
   ;

   //Number of operations (T) to evaluate if stack argument is greater than or equal to 0,5 or NaN
      !"if  "! t=U32
      tv = {;; let v = View.get_current() in
               View.restrict(v, 0, 8*t) }
      ifops  = @[tv, OpStream<nops = t>]
      { let r = { consume: 1,
                  produce: 0 } in
        o.op := operation::If(r, ifops) }

    ;
   // ... other ops
   // Stack operations, Table 96
      !"copy"!
      s=U16
      t=U16
      { let r = { consume: s+1,
                  produce: (s+1)*(t+2) } in
        o.op := operation::Copy(r)
      }
   ;

      !"rotl"!
      s=U16
      t=U16
      { let r = { consume: s+1,
                  produce: s+1 } in
        o.op := operation::Rotl(r)
      }
   ;
      !"rotr"!
      s=U16
      t=U16
      { let r = { consume: s+1,
                  produce: s+1 } in
        o.op := operation::Rotr(r)
      }
   ;

      !"posd"!
      s=U16
      t=U16
      { let r = { consume: s,
                  produce: s+t+1 } in
        o.op := operation::Posd(r)
      }
   ;

      !"flip"!
      s=U16
      t=U16
      { let r = { consume: s+1,
                  produce: s+1 } in
        o.op := operation::Flip(r)
      }
   ;

      !"pop"!
      s=U16
      t=U16
      { let r = { consume: s+1,
                  produce: 0 } in
        o.op := operation::Pop(r)
      }
   ;;

  OpStream os (nops: int) {ops: [operation]} :=
      (| l : [operation] := [], cnt : int := 0 |)

      ( [cnt < nops]
        o=Operation
        { l := o.op :: l;
          cnt := cnt + num_ops(o.op) }
      ) *
      [ cnt = nops ]

      { os.ops := List.rev(l) }
}
